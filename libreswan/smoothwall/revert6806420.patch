Description: Revert upstream commit introducing stricter cert checking.
 The upstream commit 'pluto: Perform stricter SubjectAltName checks on configured ID's'
 introduced in Libreswan 3.21 adds additional certificate checking. These additional
 checks require either FQDN or user@FQDN rightid's to match the certficates DN or SubjectAltName.
.
 Our existing certificates used for IPSec tunnels do not satisfy either of these conditions
 and without this patch tunnels auth'd by RSASIG where the certificate is generated by a
 Smoothwall (or elsewhere but still doesn't match/contain SubjectAltName) will fail to initialise.
Author: Jonathan Barron <jonathan.barron@smoothwall.net>
Origin: Revert of upstream <https://github.com/libreswan/libreswan/commit/6806420bfec59c8fa6e44d0a95a52d6878c10a6e>
--- a/programs/pluto/ikev1.c
+++ b/programs/pluto/ikev1.c
@@ -2807,10 +2807,8 @@
 	 */
 
 	if (initiator) {
-		if (!st->st_peer_alt_id &&
-			!same_id(&st->st_connection->spd.that.id, &peer) &&
-			id_kind(&st->st_connection->spd.that.id) != ID_FROMCERT) {
-
+		if (!same_id(&st->st_connection->spd.that.id, &peer) &&
+		     id_kind(&st->st_connection->spd.that.id) != ID_FROMCERT) {
 			char expect[IDTOA_BUF],
 			     found[IDTOA_BUF];
 
@@ -2865,25 +2863,20 @@
 
 		struct connection *r = NULL;
 
-		r = refine_host_connection(st, &peer, FALSE /* we are responder */,
+		if ((auth_policy & ~POLICY_AGGRESSIVE) != LEMPTY) {
+			r = refine_host_connection(st, &peer, initiator,
 				auth_policy, AUTH_UNSET /* ikev2 only */, &fromcert);
+			pexpect(r != NULL);
+		}
 
 		if (r == NULL) {
 			char buf[IDTOA_BUF];
 
 			idtoa(&peer, buf, sizeof(buf));
-			DBG(DBG_CONTROL, DBG_log(
-			       "no more suitable connection for peer '%s'", buf));
-			/* can we continue with what we had? */
-			if (!md->st->st_peer_alt_id &&
-				!same_id(&c->spd.that.id, &peer) &&
-				id_kind(&c->spd.that.id) != ID_FROMCERT) {
-					libreswan_log("Peer mismatch on first found connection and no better connection found");
-					return FALSE;
-			} else {
-				DBG(DBG_CONTROL, DBG_log("Peer ID matches and no better connection found - continuing with existing connection"));
-				r = c;
-			}
+			loglog(RC_LOG_SERIOUS,
+			       "no suitable connection for peer '%s'",
+			       buf);
+			return FALSE;
 		}
 
 		DBG(DBG_CONTROL, {
--- a/programs/pluto/ikev1_aggr.c
+++ b/programs/pluto/ikev1_aggr.c
@@ -270,7 +270,7 @@
 	}
 
 	/* warn for especially dangerous Aggressive Mode and PSK */
-	if (LIN(POLICY_PSK, c->policy) && LIN(POLICY_AGGRESSIVE, c->policy)) {
+	if ((c->policy & (POLICY_PSK & POLICY_AGGRESSIVE)) != LEMPTY) {
 		loglog(RC_LOG_SERIOUS,
 			"IKEv1 Aggressive Mode with PSK is vulnerable to dictionary attacks and is cracked on large scale by TLA's");
 	}
@@ -1165,7 +1165,7 @@
 	struct state *st;
 	struct spd_route *sr;
 
-	if (LIN(POLICY_PSK, c->policy) && LIN(POLICY_AGGRESSIVE, c->policy)) {
+	if ((c->policy & (POLICY_PSK & POLICY_AGGRESSIVE)) != LEMPTY) {
 		loglog(RC_LOG_SERIOUS,
 			"IKEv1 Aggressive Mode with PSK is vulnerable to dictionary attacks and is cracked on large scale by TLA's");
 	}
--- a/programs/pluto/ikev1_main.c
+++ b/programs/pluto/ikev1_main.c
@@ -1687,11 +1687,10 @@
 	 * ID Payload in.
 	 * Note: this may switch the connection being used!
 	 */
-	if (!st->st_peer_alt_id  && !ikev1_decode_peer_id(md, initiator, aggrmode)) {
+	if (!ikev1_decode_peer_id(md, initiator, aggrmode)) {
 	DBG(DBG_CONTROLMORE, DBG_log("Peer ID failed to decode"));
 		return STF_FAIL + INVALID_ID_INFORMATION;
 	}
-
 	/*
 	 * process any CERT payloads if aggrmode
 	 */
--- a/programs/pluto/ikev2.c
+++ b/programs/pluto/ikev2.c
@@ -1445,9 +1445,9 @@
 	 * - if opportunistic, we'll lose our HOLD info
 	 */
 	if (initiator) {
-		if (!md->st->st_peer_alt_id &&
-			!same_id(&c->spd.that.id, &peer_id) &&
-			id_kind(&st->st_connection->spd.that.id) != ID_FROMCERT) {
+		if (!same_id(&st->st_connection->spd.that.id, &peer_id) &&
+			id_kind(&st->st_connection->spd.that.id) !=
+			ID_FROMCERT) {
 
 			char expect[IDTOA_BUF],
 			     found[IDTOA_BUF];
@@ -1491,9 +1491,11 @@
 			struct connection *r = NULL;
 
 			if (authby != AUTH_NULL) {
+				/* should never return NULL */
 				r = refine_host_connection(
 				md->st, &peer_id, FALSE /*initiator*/,
 				LEMPTY /* auth_policy */, authby, &fromcert);
+				pexpect(r != NULL);
 			}
 
 			if (r == NULL) {
@@ -1501,18 +1503,8 @@
 
 				idtoa(&peer_id, buf, sizeof(buf));
 				DBG(DBG_CONTROL, DBG_log(
-					"no suitable connection for peer '%s'", buf));
-				/* can we continue with what we had? */
-				if (!md->st->st_peer_alt_id &&
-					!same_id(&c->spd.that.id, &peer_id) &&
-					id_kind(&c->spd.that.id) != ID_FROMCERT) {
-						libreswan_log("Peer mismatch on first found connection and no better connection found");
-						return FALSE;
-				} else {
-					DBG(DBG_CONTROL, DBG_log("Peer ID matches and no better connection found - continuing with existing connection"));
-					r = c;
-				}
-
+					"no refined connection for peer '%s'", buf));
+				r = c; /* ??? is this safe? */
 			}
 
 			if (r != c) {
--- a/programs/pluto/ikev2_parent.c
+++ b/programs/pluto/ikev2_parent.c
@@ -3383,7 +3383,6 @@
 	struct state *const st = md->st;
 	unsigned char idhash_in[MAX_DIGEST_LEN];
 
-	/* calculate hash of IDi for AUTH below */
 	{
 		struct hmac_ctx id_ctx;
 		const pb_stream *id_pbs = &md->chain[ISAKMP_NEXT_v2IDi]->pbs;
@@ -3391,6 +3390,8 @@
 		unsigned int idlen = pbs_room(id_pbs) - NSIZEOF_isakmp_generic;
 
 		hmac_init(&id_ctx, st->st_oakley.prf, st->st_skey_pi_nss);
+
+		/* calculate hash of IDi for AUTH below */
 		DBG(DBG_CRYPT, DBG_dump("idhash verify I2", idstart, idlen));
 		hmac_update(&id_ctx, idstart, idlen);
 		hmac_final(idhash_in, &id_ctx);
--- a/programs/pluto/nss_cert_vfy.c
+++ b/programs/pluto/nss_cert_vfy.c
@@ -1,7 +1,6 @@
 /* pluto NSS certificate verification routines
  *
  * Copyright (C) 2015 Matt Rogers <mrogers@libreswan.org>
- * Copyright (C) 2017 Paul Wouters <pwouters@redhat.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -495,95 +494,3 @@
 
 	return ret;
 }
-
-bool cert_VerifySubjectAltName(const CERTCertificate *cert, const char *name)
-{
-	SECStatus rv;
-	SECItem	subAltName;
-	PLArenaPool *arena = NULL;
-	CERTGeneralName *nameList = NULL;
-	CERTGeneralName *current = NULL;
-	bool san_ip = FALSE;
-	unsigned int len = strlen(name);
-	ip_address myip;
-
-	rv = CERT_FindCertExtension(cert, SEC_OID_X509_SUBJECT_ALT_NAME,
-			&subAltName);
-	if (rv != SECSuccess) {
-		DBG(DBG_X509, DBG_log("certificate contains no subjectAltName extension"));
-		return FALSE;
-	}
-
-	if (tnatoaddr(name, 0, AF_UNSPEC, &myip) == NULL)
-		san_ip = TRUE;
-
-	arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
-	passert(arena != NULL);
-
-	nameList = current = CERT_DecodeAltNameExtension(arena, &subAltName);
-	passert(current != NULL);
-
-	do
-	{
-		switch (current->type) {
-		case certDNSName:
-		case certRFC822Name:
-			if (san_ip)
-				break;
-			if (current->name.other.len == len) {
-				if (memcmp(current->name.other.data, name, len) == 0) {
-					DBG(DBG_X509, DBG_log("subjectAltname %s found in certificate", name));
-					PORT_FreeArena(arena, PR_FALSE);
-					return TRUE;
-				}
-			}
-
-			if (current->name.other.len != 0 && current->name.other.len < IDTOA_BUF) {
-				char osan[IDTOA_BUF];
-
-				memcpy(osan,current->name.other.data, current->name.other.len);
-				osan[current->name.other.len] = '\0';
-				DBG(DBG_X509, DBG_log("subjectAltname (len=%d) %s not match %s", current->name.other.len, osan, name));
-			} else {
-				DBG(DBG_X509, DBG_log("subjectAltname <TOO BIG TO PRINT> does not match %s", name));
-			}
-			break;
-
-		case certIPAddress:
-			if (!san_ip)
-				break;
-			if ((current->name.other.len == 4) && (addrtypeof(&myip) == AF_INET)) {
-				if (memcmp(current->name.other.data, &myip.u.v4.sin_addr.s_addr, 4) == 0) {
-					DBG(DBG_X509, DBG_log("subjectAltname IPv4 matches %s", name));
-					PORT_FreeArena(arena, PR_FALSE);
-					return TRUE;
-				} else {
-					DBG(DBG_X509, DBG_log("subjectAltname IPv4 does not match %s", name));
-					break;
-				}
-			}
-			if ((current->name.other.len == 16) && (addrtypeof(&myip) == AF_INET6)) {
-				if (memcmp(current->name.other.data, &myip.u.v6.sin6_addr.s6_addr, 16) == 0) {
-					DBG(DBG_X509, DBG_log("subjectAltname IPv6 matches %s", name));
-					PORT_FreeArena(arena, PR_FALSE);
-					return TRUE;
-				} else {
-					DBG(DBG_X509, DBG_log("subjectAltname IPv6 does not match %s", name));
-					break;
-				}
-			}
-			DBG(DBG_X509, DBG_log("subjectAltnamea IP address family mismatch for %s", name));
-			break;
-
-		default:
-			break;
-		}
-		current = CERT_GetNextGeneralName(current);
-	} while (current != nameList);
-
-	loglog(RC_LOG_SERIOUS, "No matching subjectAltName found");
-	/* Don't free nameList, it's part of the arena. */
-	PORT_FreeArena(arena, PR_FALSE);
-	return FALSE;
-}
-
--- a/programs/pluto/nss_cert_vfy.h
+++ b/programs/pluto/nss_cert_vfy.h
@@ -24,8 +24,6 @@
 						 CERTCertificate **ee_out,
 						 bool *rev_opts);
 
-extern bool cert_VerifySubjectAltName(const CERTCertificate *cert, const char *name);
-
 /* rev_opts index */
 #define RO_OCSP 0
 #define RO_OCSP_S 1
--- a/programs/pluto/x509.c
+++ b/programs/pluto/x509.c
@@ -304,13 +304,42 @@
  */
 void select_nss_cert_id(CERTCertificate *cert, struct id *end_id)
 {
-	if (end_id->kind == ID_FROMCERT) {
+	bool use_dn = FALSE;	/* ID is subject DN */
+
+	/* check for cert email addr first */
+	if (end_id->kind == ID_USER_FQDN) {
+		char email[IDTOA_BUF];
+
+		idtoa(end_id, email, IDTOA_BUF);
+		if (cert->emailAddr == NULL || !streq(cert->emailAddr, email)) {
+			DBG(DBG_X509,
+			    DBG_log("no email \'%s\' for cert, using ASN1 subjectName",
+						email));
+			use_dn = TRUE;
+		}
+	}
+
+	if (end_id->kind == ID_DER_ASN1_DN) {
+		chunk_t certdn = same_secitem_as_chunk(cert->derSubject);
+
+		if (!same_dn_any_order(end_id->name, certdn)) {
+			char idb[IDTOA_BUF];
+
+			idtoa(end_id, idb, IDTOA_BUF);
+			DBG(DBG_X509,
+			    DBG_log("no subject \'%s\' for cert, using ASN1 subjectName \'%s\'",
+						idb, cert->subjectName));
+			use_dn = TRUE;
+		}
+	}
+
+	if (end_id->kind == ID_FROMCERT || end_id->kind == ID_NONE || use_dn) {
 		DBG(DBG_X509,
-                    DBG_log("setting ID to ID_DER_ASN1_DN: \'%s\'", cert->subjectName));
+		    DBG_log("setting ID to ID_DER_ASN1_DN: \'%s\'",
+			    cert->subjectName));
 		end_id->name = same_secitem_as_chunk(cert->derSubject);
 		end_id->kind = ID_DER_ASN1_DN;
 	}
-
 }
 
 static char *make_crl_uri_str(chunk_t *uri)
@@ -733,9 +762,6 @@
 #endif
 	int cont = LSW_CERT_BAD;
 	bool rev_opts[RO_SZ];
-	char namebuf[IDTOA_BUF];
-	char ipstr[IDTOA_BUF];
-	char sbuf[ASN1_BUF_LEN];
 
 	rev_opts[RO_OCSP] = ocsp_enable;
 	rev_opts[RO_OCSP_S] = ocsp_strict;
@@ -753,107 +779,10 @@
 	}
 
 	if ((ret & VERIFY_RET_OK) && end_cert != NULL) {
-		libreswan_log("certificate verified OK: %s", end_cert->subjectName);
+		libreswan_log("certificate %s OK", end_cert->subjectName);
+		c->spd.that.cert.u.nss_cert = end_cert;
+		c->spd.that.cert.ty = CERT_X509_SIGNATURE;
 		add_rsa_pubkey_from_cert(&c->spd.that.id, end_cert);
-
-		/* if we already verified ID, no need to do it again */
-		if (st->st_peer_alt_id) {
-			DBG(DBG_X509, DBG_log("Peer ID was already confirmed"));
-			return LSW_CERT_ID_OK;
-		}
-
-		DBG(DBG_X509, DBG_log("Verifying configured ID matches certificate"));
-
-		switch (c->spd.that.id.kind) {
-		case ID_IPV4_ADDR:
-		case ID_IPV6_ADDR:
-			idtoa(&c->spd.that.id, ipstr, sizeof(ipstr));
-			if (cert_VerifySubjectAltName(end_cert, ipstr)) {
-				st->st_peer_alt_id = TRUE;
-				cont = LSW_CERT_ID_OK;
-				DBG(DBG_X509, DBG_log("ID_IP '%s' matched", ipstr));
-			} else {
-				loglog(RC_LOG_SERIOUS, "certificate does not contain ID_IP subjectAltName=%s",
-						ipstr);
-				return LSW_CERT_MISMATCHED_ID; /* signal connswitch */
-			}
-			break;
-
-		case ID_FQDN:
-			/* We need to skip the "@" prefix from our configured FQDN */
-			idtoa(&c->spd.that.id, namebuf, sizeof(namebuf));
-
-			 if (cert_VerifySubjectAltName(end_cert, namebuf + 1)) {
-				st->st_peer_alt_id = TRUE;
-				cont = LSW_CERT_ID_OK;
-				DBG(DBG_X509, DBG_log("ID_FQDN '%s' matched", namebuf+1));
-			} else {
-				loglog(RC_LOG_SERIOUS, "certificate does not contain subjectAltName=%s",
-					namebuf + 1);
-				return LSW_CERT_MISMATCHED_ID; /* signal conn switch */
-			}
-			break;
-
-		case ID_USER_FQDN:
-			idtoa(&c->spd.that.id, namebuf, sizeof(namebuf));
-			if (cert_VerifySubjectAltName(end_cert, namebuf)) {
-				st->st_peer_alt_id = TRUE;
-				cont = LSW_CERT_ID_OK;
-				DBG(DBG_X509, DBG_log("ID_USER_FQDN '%s' matched", namebuf));
-			} else {
-				loglog(RC_LOG_SERIOUS, "certificate does not contain ID_USER_FQDN subjectAltName=%s",
-					namebuf);
-				return LSW_CERT_MISMATCHED_ID; /* signal conn switch */
-			}
-			break;
-
-		case ID_FROMCERT:
-			/* We are commited to accept any ID as long as the CERT verified */
-			st->st_peer_alt_id = TRUE;
-			cont = LSW_CERT_ID_OK;
-			idtoa(&c->spd.that.id, namebuf, sizeof(namebuf));
-			DBG(DBG_X509, DBG_log("ID_DER_ASN1_DN '%s' does not need further ID verification", namebuf));
-
-			{
-				struct id peer_id;
-				memset(&peer_id, 0x00, sizeof(struct id)); /* rhbz#1392191 */
-				peer_id.kind = ID_DER_ASN1_DN;
-				peer_id.name = same_secitem_as_chunk(end_cert->derSubject);
-				duplicate_id(&c->spd.that.id, &peer_id);
-			}
-			break;
-
-		case ID_DER_ASN1_DN:
-			idtoa(&c->spd.that.id, namebuf, sizeof(namebuf));
-			dntoasi(sbuf, sizeof(sbuf), end_cert->derSubject);
-			DBG(DBG_X509, DBG_log("ID_DER_ASN1_DN '%s' needs further ID comparison against '%s'",
-				sbuf, namebuf));
-
-			chunk_t certdn = same_secitem_as_chunk(end_cert->derSubject);
-
-			if (same_dn_any_order(c->spd.that.id.name, certdn)) {
-				DBG(DBG_X509, DBG_log("ID_DER_ASN1_DN '%s' matched our ID", namebuf));
-				st->st_peer_alt_id = TRUE;
-				cont = LSW_CERT_ID_OK;
-			} else {
-				loglog(RC_LOG_SERIOUS, "ID_DER_ASN1_DN '%s' does not match expected '%s'",
-					end_cert->subjectName, namebuf);
-				return LSW_CERT_MISMATCHED_ID; /* signal conn switch */
-			}
-			break;
-		default:
-			loglog(RC_LOG_SERIOUS, "Unhandled ID type %d: %s",
-				c->spd.that.id.kind,
-				enum_show(&ike_idtype_names, c->spd.that.id.kind));
-				return LSW_CERT_BAD;
-		}
-
-		if (st->st_peer_alt_id) {
-			DBG(DBG_X509, DBG_log("SAN ID matched, updating that.cert"));
-			c->spd.that.cert.u.nss_cert = end_cert;
-			c->spd.that.cert.ty = CERT_X509_SIGNATURE;
-			return LSW_CERT_ID_OK;
-		}
 	} else if (ret & VERIFY_RET_REVOKED) {
 		libreswan_log("certificate revoked!");
 		cont = LSW_CERT_BAD;
@@ -901,7 +830,6 @@
 	int der_num = 0;
 	int np = st->st_ikev2 ? ISAKMP_NEXT_v2CERT : ISAKMP_NEXT_CERT;
 
-	DBG(DBG_X509, DBG_log("checking for CERT payloads"));
 	for (p = md->chain[np]; p != NULL; p = p->next) {
 		struct isakmp_cert *cert;
 		struct ikev2_cert *v2cert;
@@ -927,22 +855,9 @@
 	}
 
 	if (der_num > 0) {
-		DBG(DBG_X509, DBG_log("found at last one CERT payload, calling pluto_process_certs()"));
-		switch (pluto_process_certs(st, der_list, der_num)) {
-		case LSW_CERT_BAD:
-			libreswan_log("X509: Certificate rejected for this connection");
-			ret = LSW_CERT_BAD;
-			break;
-		case LSW_CERT_MISMATCHED_ID:
-			libreswan_log("Peer public key SubjectAltName does not match peer ID for this connection");
-			ret = LSW_CERT_MISMATCHED_ID;
-			break;
-		case LSW_CERT_ID_OK:
-			DBG(DBG_X509, DBG_log("Peer public key SubjectAltName matches peer ID for this connection"));
-			ret = LSW_CERT_ID_OK;
-			break;
-		default:
-			passert(FALSE);
+		if (!pluto_process_certs(st, der_list, der_num)) {
+			libreswan_log("Peer public key is not available for this exchange");
+			ret = FALSE;
 		}
 
 		while (der_num-- > 0)
