diff -Nurb traceroute-1.4a12.old/apply traceroute-1.4a12/apply
--- traceroute-1.4a12.old/apply	1970-01-01 01:00:00.000000000 +0100
+++ traceroute-1.4a12/apply	2004-08-16 13:11:03.000000000 +0100
@@ -0,0 +1,17 @@
+patch -b -p1 <../traceroute-1.4a5-fix.patch
+patch -b -p1 <../traceroute-1.4a5-secfix.patch
+#patch -b -p1 <../traceroute-1.4a5-alpha.patch
+patch -b -p1 <../traceroute-1.4a5-autoroute.patch
+patch -b -p1 <../traceroute-1.4a5-autoroute2.patch
+patch -b -p1 <../traceroute-1.4a5-unaligned.patch
+patch -b -p1 <../traceroute-1.4a5-llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch.patch
+patch -b -p1 <../traceroute-1.4a5-fhs.patch
+#patch -b -p1 <../traceroute-1.4a5-sourceroute.patch
+patch -b -p1 <../traceroute-1.4a5-aliases.patch
+patch -b -p1 <../traceroute-1.4a5-droproot.patch
+patch -b -p1 <../traceroute-1.4a5-bigpacklen.patch
+patch -b -p1 <../traceroute-1.4a5-lsrr.patch
+patch -b -p1 <../traceroute-1.4a12-sockopt.patch
+patch -b -p1 <../traceroute-1.4a12-sockopt2.patch
+patch -b -p1 <../traceroute-1.4a12-tos-monitoring.patch
+patch -b -p1 <../traceroute-1.4a12-mpls-icmp-02.patch
diff -Nurb traceroute-1.4a12.old/configure traceroute-1.4a12/configure
--- traceroute-1.4a12.old/configure	2000-12-18 09:34:24.000000000 +0000
+++ traceroute-1.4a12/configure	2004-08-16 13:11:06.000000000 +0100
@@ -761,7 +761,7 @@
   # We found a bogon in the path, so make sure we never use it.
   set dummy $ac_cv_prog_CC
   shift
-  if test $# -gt 0; then
+  if test $# -gt 0 ; then
     # We chose a different compiler from the bogus one.
     # However, it has the same basename, so the bogon will be chosen
     # first if we set CC to just the basename; use the full file name.
@@ -1789,11 +1789,13 @@
 	;;
 
 linux*)
-	V_INCLS="$V_INCLS -Ilinux-include"
 	cat >> confdefs.h <<\EOF
-#define BYTESWAP_IP_HDR 1
+#define HAVE_RAW_OPTIONS 1
+#define BYTESWAP_IP_LEN 1
+#define HAVE_IFF_LOOPBACK 1
+#define USE_KERNEL_ROUTING_TABLE 1
 EOF
-
+	V_INCLS="$V_INCLS -Ilinux-include"
 	;;
 
 osf3*)
@@ -1934,6 +1936,9 @@
 			    sed -e 's/\..*//'`
 fi
 
+		    # XXX hack for Red Hat linux
+		    ac_cv_lbl_gcc_vers=2
+
 		    echo "$ac_t""$ac_cv_lbl_gcc_vers" 1>&6
 		    if test $ac_cv_lbl_gcc_vers -gt 1 ; then
 			    V_CCOPT="`echo $V_CCOPT | sed -e 's/-O/-O2/'`"
@@ -2320,7 +2325,7 @@
 ac_more_lines=:
 ac_sed_cmds=""
 while $ac_more_lines; do
-  if test $ac_beg -gt 1; then
+  if test $ac_beg -gt 1 ; then
     sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
   else
     sed "${ac_end}q" conftest.subs > conftest.s$ac_file
diff -Nurb traceroute-1.4a12.old/configure.in traceroute-1.4a12/configure.in
--- traceroute-1.4a12.old/configure.in	2000-12-18 09:38:29.000000000 +0000
+++ traceroute-1.4a12/configure.in	2004-08-16 13:11:06.000000000 +0100
@@ -44,7 +44,7 @@
 	;;
 
 linux*)
-	V_INCLS="$V_INCLS -Ilinux-include"
+	V_INCLS="$V_INCLS -Ilinux-include -DHAVE_IFF_LOOPBACK -DUSE_KERNEL_ROUTING_TABLE"
 	AC_DEFINE(BYTESWAP_IP_HDR)
 	;;
 
diff -Nurb traceroute-1.4a12.old/configure.in.orig traceroute-1.4a12/configure.in.orig
--- traceroute-1.4a12.old/configure.in.orig	1970-01-01 01:00:00.000000000 +0100
+++ traceroute-1.4a12/configure.in.orig	2004-08-16 13:11:06.000000000 +0100
@@ -0,0 +1,140 @@
+dnl @(#) $Id: traceroute-1.4a12-fc2.patch,v 1.1 2004/08/16 12:48:24 lawrence Exp $ (LBL)
+dnl
+dnl Copyright (c) 1995, 1996, 1997, 1999, 2000
+dnl	The Regents of the University of California.  All rights reserved.
+dnl
+dnl Process this file with autoconf to produce a configure script.
+dnl
+
+AC_INIT(traceroute.c)
+
+AC_CANONICAL_SYSTEM
+
+umask 002
+
+if test -z "$PWD" ; then
+	PWD=`pwd`
+fi
+
+AC_LBL_C_INIT(V_CCOPT, V_INCLS)
+
+AC_CHECK_HEADERS(malloc.h sys/select.h sys/sockio.h net/route.h \
+    net/if_dl.h inet/mib2.h)
+
+AC_REPLACE_FUNCS(strerror usleep)
+AC_CHECK_FUNCS(setlinebuf)
+if test $ac_cv_func_usleep = "no" ; then
+	AC_CHECK_FUNCS(nanosleep)
+fi
+
+AC_LBL_LIBRARY_NET
+
+case "$target_os" in
+
+bsd4*)
+	AC_DEFINE(HAVE_RAW_OPTIONS)
+	;;
+
+bsdi*)
+	AC_DEFINE(HAVE_RAW_OPTIONS)
+	;;
+
+freebsd*)
+	AC_DEFINE(HAVE_RAW_OPTIONS)
+	;;
+
+linux*)
+	V_INCLS="$V_INCLS -Ilinux-include -DHAVE_IFF_LOOPBACK"
+	AC_DEFINE(BYTESWAP_IP_HDR)
+	;;
+
+osf3*)
+	dnl Workaround around ip_hl vs. ip_vhl problem in netinet/ip.h
+	AC_DEFINE(__STDC__,2)
+	;;
+
+solaris2.[[012345]]*)
+	AC_DEFINE(BYTESWAP_IP_HDR)
+	AC_DEFINE(CANT_HACK_IPCKSUM)
+	;;
+
+solaris*)
+	AC_DEFINE(BYTESWAP_IP_HDR)
+	;;
+esac
+
+dnl
+dnl What kind of routing table lookup do we have?
+dnl
+AC_MSG_CHECKING(routing table type)
+t="generic"
+if test $ac_cv_header_inet_mib2_h = yes ; then
+	t="mib"
+elif test $ac_cv_header_net_route_h = yes -a \
+    $ac_cv_header_net_if_dl_h = yes ; then
+	t="socket"
+elif test -f /proc/net/route ; then
+	t="linux"
+fi
+
+AC_MSG_RESULT(${t})
+V_FINDSADDR="findsaddr-${t}.c"
+
+
+AC_LBL_CHECK_TYPE(int32_t, int)
+AC_LBL_CHECK_TYPE(u_int32_t, u_int)
+
+AC_LBL_DEVEL(V_CCOPT)
+
+AC_LBL_SOCKADDR_SA_LEN
+
+AC_MSG_CHECKING(if struct icmp has icmp_nextmtu)
+AC_CACHE_VAL(ac_cv_struct_icmp_has_icmp_nextmtu,
+    LBL_SAVE_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS $V_INCLS"
+    AC_TRY_COMPILE([   
+#       include <sys/param.h>
+#	include <sys/socket.h>
+#	include <netinet/in_systm.h>
+#       if __STDC__
+        /* osf3 has REALLY good prototyes */
+        struct mbuf;
+        struct rtentry;
+#       endif
+#       include <netinet/in.h>
+#       include <netinet/ip.h>
+#       include <netinet/ip_icmp.h>
+#       include <netinet/if_ether.h>],
+	[u_int i = sizeof(((struct icmp *)0)->icmp_nextmtu)],
+	ac_cv_struct_icmp_has_icmp_nextmtu=yes,
+	ac_cv_struct_icmp_has_icmp_nextmtu=no)
+    CFLAGS="$LBL_SAVE_CFLAGS")
+AC_MSG_RESULT($ac_cv_struct_icmp_has_icmp_nextmtu)
+if test $ac_cv_struct_icmp_has_icmp_nextmtu = yes ; then
+	AC_DEFINE(HAVE_ICMP_NEXTMTU)
+fi
+
+if test "${srcdir}" = "." ; then
+	srcdirprefix=""
+else
+	srcdirprefix="./"
+fi
+
+if test -r ${srcdirprefix}lbl/gnuc.h ; then
+	rm -f gnuc.h
+	ln -s ${srcdirprefix}lbl/gnuc.h gnuc.h
+fi
+
+AC_SUBST(V_CCOPT)
+AC_SUBST(V_INCLS)
+AC_SUBST(V_FINDSADDR)
+
+AC_PROG_INSTALL
+
+AC_OUTPUT(Makefile)
+
+if test -f .devel ; then
+	make depend
+fi
+
+exit 0
diff -Nurb traceroute-1.4a12.old/configure.orig traceroute-1.4a12/configure.orig
--- traceroute-1.4a12.old/configure.orig	1970-01-01 01:00:00.000000000 +0100
+++ traceroute-1.4a12/configure.orig	2004-08-16 13:11:06.000000000 +0100
@@ -0,0 +1,2428 @@
+#! /bin/sh
+
+# Guess values for system-dependent variables and create Makefiles.
+# Generated automatically using autoconf version 2.13 
+# Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+
+# Defaults:
+ac_help=
+ac_default_prefix=/usr/local
+# Any additions from configure.in:
+ac_help="$ac_help
+  --without-gcc           don't use gcc"
+
+# Initialize some variables set by options.
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+build=NONE
+cache_file=./config.cache
+exec_prefix=NONE
+host=NONE
+no_create=
+nonopt=NONE
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+target=NONE
+verbose=
+x_includes=NONE
+x_libraries=NONE
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+# Initialize some other variables.
+subdirs=
+MFLAGS= MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+# Maximum number of lines to put in a shell here document.
+ac_max_here_lines=12
+
+ac_prev=
+for ac_option
+do
+
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  case "$ac_option" in
+  -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) ac_optarg= ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case "$ac_option" in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir="$ac_optarg" ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build="$ac_optarg" ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file="$ac_optarg" ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir="$ac_optarg" ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
+      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
+    fi
+    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
+    eval "enable_${ac_feature}=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
+      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
+    fi
+    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
+    case "$ac_option" in
+      *=*) ;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_${ac_feature}='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix="$ac_optarg" ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he)
+    # Omit some internal or obsolete options to make the list less imposing.
+    # This message is too long to be a string in the A/UX 3.1 sh.
+    cat << EOF
+Usage: configure [options] [host]
+Options: [defaults in brackets after descriptions]
+Configuration:
+  --cache-file=FILE       cache test results in FILE
+  --help                  print this message
+  --no-create             do not create output files
+  --quiet, --silent       do not print \`checking...' messages
+  --version               print the version of autoconf that created configure
+Directory and file names:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [same as prefix]
+  --bindir=DIR            user executables in DIR [EPREFIX/bin]
+  --sbindir=DIR           system admin executables in DIR [EPREFIX/sbin]
+  --libexecdir=DIR        program executables in DIR [EPREFIX/libexec]
+  --datadir=DIR           read-only architecture-independent data in DIR
+                          [PREFIX/share]
+  --sysconfdir=DIR        read-only single-machine data in DIR [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data in DIR
+                          [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data in DIR [PREFIX/var]
+  --libdir=DIR            object code libraries in DIR [EPREFIX/lib]
+  --includedir=DIR        C header files in DIR [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc in DIR [/usr/include]
+  --infodir=DIR           info documentation in DIR [PREFIX/info]
+  --mandir=DIR            man documentation in DIR [PREFIX/man]
+  --srcdir=DIR            find the sources in DIR [configure dir or ..]
+  --program-prefix=PREFIX prepend PREFIX to installed program names
+  --program-suffix=SUFFIX append SUFFIX to installed program names
+  --program-transform-name=PROGRAM
+                          run sed PROGRAM on installed program names
+EOF
+    cat << EOF
+Host type:
+  --build=BUILD           configure for building on BUILD [BUILD=HOST]
+  --host=HOST             configure for HOST [guessed]
+  --target=TARGET         configure for TARGET [TARGET=HOST]
+Features and packages:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --x-includes=DIR        X include files are in DIR
+  --x-libraries=DIR       X library files are in DIR
+EOF
+    if test -n "$ac_help"; then
+      echo "--enable and --with options recognized:$ac_help"
+    fi
+    exit 0 ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host="$ac_optarg" ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir="$ac_optarg" ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir="$ac_optarg" ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir="$ac_optarg" ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir="$ac_optarg" ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir="$ac_optarg" ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir="$ac_optarg" ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir="$ac_optarg" ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix="$ac_optarg" ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix="$ac_optarg" ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix="$ac_optarg" ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name="$ac_optarg" ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir="$ac_optarg" ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir="$ac_optarg" ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site="$ac_optarg" ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir="$ac_optarg" ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir="$ac_optarg" ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target="$ac_optarg" ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers)
+    echo "configure generated by autoconf version 2.13"
+    exit 0 ;;
+
+  -with-* | --with-*)
+    ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
+      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
+    fi
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case "$ac_option" in
+      *=*) ;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_${ac_package}='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`echo $ac_option|sed -e 's/-*without-//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
+      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
+    fi
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    eval "with_${ac_package}=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes="$ac_optarg" ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries="$ac_optarg" ;;
+
+  -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
+    ;;
+
+  *)
+    if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
+      echo "configure: warning: $ac_option: invalid host type" 1>&2
+    fi
+    if test "x$nonopt" != xNONE; then
+      { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
+    fi
+    nonopt="$ac_option"
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
+fi
+
+trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
+
+# File descriptor usage:
+# 0 standard input
+# 1 file creation
+# 2 errors and warnings
+# 3 some systems may open it to /dev/tty
+# 4 used on the Kubota Titan
+# 6 checking for... messages and results
+# 5 compiler messages saved in config.log
+if test "$silent" = yes; then
+  exec 6>/dev/null
+else
+  exec 6>&1
+fi
+exec 5>./config.log
+
+echo "\
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+" 1>&5
+
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Also quote any args containing shell metacharacters.
+ac_configure_args=
+for ac_arg
+do
+  case "$ac_arg" in
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c) ;;
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
+  *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
+  ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+  *) ac_configure_args="$ac_configure_args $ac_arg" ;;
+  esac
+done
+
+# NLS nuisances.
+# Only set these to C if already set.  These must not be set unconditionally
+# because not all systems understand e.g. LANG=C (notably SCO).
+# Fixing LC_MESSAGES prevents Solaris sh from translating var values in `set'!
+# Non-C LC_CTYPE values break the ctype check.
+if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
+if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
+if test "${LC_MESSAGES+set}" = set; then LC_MESSAGES=C; export LC_MESSAGES; fi
+if test "${LC_CTYPE+set}"    = set; then LC_CTYPE=C;    export LC_CTYPE;    fi
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo > confdefs.h
+
+# A filename unique to this package, relative to the directory that
+# configure is in, which we can look for to find out if srcdir is correct.
+ac_unique_file=traceroute.c
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_prog=$0
+  ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
+  test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
+  else
+    { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
+  fi
+fi
+srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
+
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    echo "loading site script $ac_site_file"
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  echo "loading cache $cache_file"
+  . $cache_file
+else
+  echo "creating cache $cache_file"
+  > $cache_file
+fi
+
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+ac_exeext=
+ac_objext=o
+if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
+  # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
+  if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
+    ac_n= ac_c='
+' ac_t='	'
+  else
+    ac_n=-n ac_c= ac_t=
+  fi
+else
+  ac_n= ac_c='\c' ac_t=
+fi
+
+
+
+ac_aux_dir=
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { echo "configure: error: can not find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." 1>&2; exit 1; }
+fi
+ac_config_guess=$ac_aux_dir/config.guess
+ac_config_sub=$ac_aux_dir/config.sub
+ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.
+
+
+# Do some error checking and defaulting for the host and target type.
+# The inputs are:
+#    configure --host=HOST --target=TARGET --build=BUILD NONOPT
+#
+# The rules are:
+# 1. You are not allowed to specify --host, --target, and nonopt at the
+#    same time.
+# 2. Host defaults to nonopt.
+# 3. If nonopt is not specified, then host defaults to the current host,
+#    as determined by config.guess.
+# 4. Target and build default to nonopt.
+# 5. If nonopt is not specified, then target and build default to host.
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+case $host---$target---$nonopt in
+NONE---*---* | *---NONE---* | *---*---NONE) ;;
+*) { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; } ;;
+esac
+
+
+# Make sure we can run config.sub.
+if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :
+else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
+fi
+
+echo $ac_n "checking host system type""... $ac_c" 1>&6
+echo "configure:575: checking host system type" >&5
+
+host_alias=$host
+case "$host_alias" in
+NONE)
+  case $nonopt in
+  NONE)
+    if host_alias=`${CONFIG_SHELL-/bin/sh} $ac_config_guess`; then :
+    else { echo "configure: error: can not guess host type; you must specify one" 1>&2; exit 1; }
+    fi ;;
+  *) host_alias=$nonopt ;;
+  esac ;;
+esac
+
+host=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $host_alias`
+host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$host" 1>&6
+
+echo $ac_n "checking target system type""... $ac_c" 1>&6
+echo "configure:596: checking target system type" >&5
+
+target_alias=$target
+case "$target_alias" in
+NONE)
+  case $nonopt in
+  NONE) target_alias=$host_alias ;;
+  *) target_alias=$nonopt ;;
+  esac ;;
+esac
+
+target=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $target_alias`
+target_cpu=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$target" 1>&6
+
+echo $ac_n "checking build system type""... $ac_c" 1>&6
+echo "configure:614: checking build system type" >&5
+
+build_alias=$build
+case "$build_alias" in
+NONE)
+  case $nonopt in
+  NONE) build_alias=$host_alias ;;
+  *) build_alias=$nonopt ;;
+  esac ;;
+esac
+
+build=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $build_alias`
+build_cpu=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$build" 1>&6
+
+test "$host_alias" != "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+
+
+umask 002
+
+if test -z "$PWD" ; then
+	PWD=`pwd`
+fi
+
+
+    
+    
+    
+    # Check whether --with-gcc or --without-gcc was given.
+if test "${with_gcc+set}" = set; then
+  withval="$with_gcc"
+  :
+fi
+
+    V_CCOPT="-O"
+    V_INCLS=""
+    if test "${srcdir}" != "." ; then
+	    V_INCLS="-I\$\(srcdir\)"
+    fi
+    if test "${CFLAGS+set}" = set; then
+	    LBL_CFLAGS="$CFLAGS"
+    fi
+    if test -z "$CC" ; then
+	    case "$target_os" in
+
+	    bsdi*)
+		    # Extract the first word of "shlicc2", so it can be a program name with args.
+set dummy shlicc2; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:668: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_SHLICC2'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$SHLICC2"; then
+  ac_cv_prog_SHLICC2="$SHLICC2" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_SHLICC2="yes"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_prog_SHLICC2" && ac_cv_prog_SHLICC2="no"
+fi
+fi
+SHLICC2="$ac_cv_prog_SHLICC2"
+if test -n "$SHLICC2"; then
+  echo "$ac_t""$SHLICC2" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+		    if test $SHLICC2 = yes ; then
+			    CC=shlicc2
+			    export CC
+		    fi
+		    ;;
+	    esac
+    fi
+    if test -z "$CC" -a "$with_gcc" = no ; then
+	    CC=cc
+	    export CC
+    fi
+    # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:709: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_CC="gcc"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:739: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_prog_rejected=no
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
+        ac_prog_rejected=yes
+	continue
+      fi
+      ac_cv_prog_CC="cc"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# -gt 0 ; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    set dummy "$ac_dir/$ac_word" "$@"
+    shift
+    ac_cv_prog_CC="$@"
+  fi
+fi
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+  if test -z "$CC"; then
+    case "`uname -s`" in
+    *win32* | *WIN32*)
+      # Extract the first word of "cl", so it can be a program name with args.
+set dummy cl; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:790: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_CC="cl"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+ ;;
+    esac
+  fi
+  test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
+fi
+
+echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
+echo "configure:822: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+cat > conftest.$ac_ext << EOF
+
+#line 833 "configure"
+#include "confdefs.h"
+
+main(){return(0);}
+EOF
+if { (eval echo configure:838: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  ac_cv_prog_cc_works=yes
+  # If we can't run a trivial program, we are probably using a cross compiler.
+  if (./conftest; exit) 2>/dev/null; then
+    ac_cv_prog_cc_cross=no
+  else
+    ac_cv_prog_cc_cross=yes
+  fi
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  ac_cv_prog_cc_works=no
+fi
+rm -fr conftest*
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
+if test $ac_cv_prog_cc_works = no; then
+  { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
+fi
+echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
+echo "configure:864: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
+cross_compiling=$ac_cv_prog_cc_cross
+
+echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
+echo "configure:869: checking whether we are using GNU C" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.c <<EOF
+#ifdef __GNUC__
+  yes;
+#endif
+EOF
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:878: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+  ac_cv_prog_gcc=yes
+else
+  ac_cv_prog_gcc=no
+fi
+fi
+
+echo "$ac_t""$ac_cv_prog_gcc" 1>&6
+
+if test $ac_cv_prog_gcc = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+
+ac_test_CFLAGS="${CFLAGS+set}"
+ac_save_CFLAGS="$CFLAGS"
+CFLAGS=
+echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
+echo "configure:897: checking whether ${CC-cc} accepts -g" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  echo 'void f(){}' > conftest.c
+if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
+  ac_cv_prog_cc_g=yes
+else
+  ac_cv_prog_cc_g=no
+fi
+rm -f conftest*
+
+fi
+
+echo "$ac_t""$ac_cv_prog_cc_g" 1>&6
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS="$ac_save_CFLAGS"
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+
+    if test "$GCC" != yes ; then
+	    echo $ac_n "checking that $CC handles ansi prototypes""... $ac_c" 1>&6
+echo "configure:930: checking that $CC handles ansi prototypes" >&5
+	    if eval "test \"`echo '$''{'ac_cv_lbl_cc_ansi_prototypes'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 935 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+int main() {
+int frob(int, char *)
+; return 0; }
+EOF
+if { (eval echo configure:942: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_lbl_cc_ansi_prototypes=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_lbl_cc_ansi_prototypes=no
+fi
+rm -f conftest*
+fi
+
+	    echo "$ac_t""$ac_cv_lbl_cc_ansi_prototypes" 1>&6
+	    if test $ac_cv_lbl_cc_ansi_prototypes = no ; then
+		    case "$target_os" in
+
+		    hpux*)
+			    echo $ac_n "checking for HP-UX ansi compiler ($CC -Aa -D_HPUX_SOURCE)""... $ac_c" 1>&6
+echo "configure:960: checking for HP-UX ansi compiler ($CC -Aa -D_HPUX_SOURCE)" >&5
+			    savedcflags="$CFLAGS"
+			    CFLAGS="-Aa -D_HPUX_SOURCE $CFLAGS"
+			    if eval "test \"`echo '$''{'ac_cv_lbl_cc_hpux_cc_aa'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 967 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+int main() {
+int frob(int, char *)
+; return 0; }
+EOF
+if { (eval echo configure:974: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_lbl_cc_hpux_cc_aa=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_lbl_cc_hpux_cc_aa=no
+fi
+rm -f conftest*
+fi
+
+			    echo "$ac_t""$ac_cv_lbl_cc_hpux_cc_aa" 1>&6
+			    if test $ac_cv_lbl_cc_hpux_cc_aa = no ; then
+				    { echo "configure: error: see the INSTALL doc for more info" 1>&2; exit 1; }
+			    fi
+			    CFLAGS="$savedcflags"
+			    V_CCOPT="-Aa $V_CCOPT"
+			    cat >> confdefs.h <<\EOF
+#define _HPUX_SOURCE 1
+EOF
+
+			    ;;
+
+		    *)
+			    { echo "configure: error: see the INSTALL doc for more info" 1>&2; exit 1; }
+			    ;;
+		    esac
+	    fi
+	    V_INCLS="$V_INCLS -I/usr/local/include"
+	    LDFLAGS="$LDFLAGS -L/usr/local/lib"
+
+	    case "$target_os" in
+
+	    irix*)
+		    V_CCOPT="$V_CCOPT -xansi -signed -g3"
+		    ;;
+
+	    osf*)
+		    V_CCOPT="$V_CCOPT -std1 -g3"
+		    ;;
+
+	    ultrix*)
+		    echo $ac_n "checking that Ultrix $CC hacks const in prototypes""... $ac_c" 1>&6
+echo "configure:1018: checking that Ultrix $CC hacks const in prototypes" >&5
+		    if eval "test \"`echo '$''{'ac_cv_lbl_cc_const_proto'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1023 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+int main() {
+struct a { int b; };
+			    void c(const struct a *)
+; return 0; }
+EOF
+if { (eval echo configure:1031: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_lbl_cc_const_proto=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_lbl_cc_const_proto=no
+fi
+rm -f conftest*
+fi
+
+		    echo "$ac_t""$ac_cv_lbl_cc_const_proto" 1>&6
+		    if test $ac_cv_lbl_cc_const_proto = no ; then
+			    cat >> confdefs.h <<\EOF
+#define const 
+EOF
+
+		    fi
+		    ;;
+	    esac
+    fi
+
+
+echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
+echo "configure:1056: checking how to run the C preprocessor" >&5
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+if eval "test \"`echo '$''{'ac_cv_prog_CPP'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    # This must be in double quotes, not single quotes, because CPP may get
+  # substituted into the Makefile and "${CC-cc}" will confuse make.
+  CPP="${CC-cc} -E"
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp.
+  cat > conftest.$ac_ext <<EOF
+#line 1071 "configure"
+#include "confdefs.h"
+#include <assert.h>
+Syntax Error
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1077: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  :
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CPP="${CC-cc} -E -traditional-cpp"
+  cat > conftest.$ac_ext <<EOF
+#line 1088 "configure"
+#include "confdefs.h"
+#include <assert.h>
+Syntax Error
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1094: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  :
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CPP="${CC-cc} -nologo -E"
+  cat > conftest.$ac_ext <<EOF
+#line 1105 "configure"
+#include "confdefs.h"
+#include <assert.h>
+Syntax Error
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1111: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  :
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CPP=/lib/cpp
+fi
+rm -f conftest*
+fi
+rm -f conftest*
+fi
+rm -f conftest*
+  ac_cv_prog_CPP="$CPP"
+fi
+  CPP="$ac_cv_prog_CPP"
+else
+  ac_cv_prog_CPP="$CPP"
+fi
+echo "$ac_t""$CPP" 1>&6
+
+for ac_hdr in malloc.h sys/select.h sys/sockio.h net/route.h \
+    net/if_dl.h inet/mib2.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:1140: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1145 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1150: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+
+for ac_func in strerror usleep
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:1180: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1185 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:1208: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+LIBOBJS="$LIBOBJS ${ac_func}.${ac_objext}"
+fi
+done
+
+
+for ac_func in setlinebuf
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:1237: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1242 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:1265: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+if test $ac_cv_func_usleep = "no" ; then
+	for ac_func in nanosleep
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:1293: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1298 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:1321: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+fi
+
+
+    # Most operating systems have gethostbyname() in the default searched
+    # libraries (i.e. libc):
+    echo $ac_n "checking for gethostbyname""... $ac_c" 1>&6
+echo "configure:1351: checking for gethostbyname" >&5
+if eval "test \"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1356 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char gethostbyname(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char gethostbyname();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_gethostbyname) || defined (__stub___gethostbyname)
+choke me
+#else
+gethostbyname();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:1379: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_gethostbyname=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_gethostbyname=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'gethostbyname`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  :
+else
+  echo "$ac_t""no" 1>&6
+# Some OSes (eg. Solaris) place it in libnsl:
+	echo $ac_n "checking for gethostbyname in -lnsl""... $ac_c" 1>&6
+echo "configure:1398: checking for gethostbyname in -lnsl" >&5
+ac_lib_var=`echo nsl'_'gethostbyname'_' | sed 'y%./+- %__p__%'`
+if eval "test \"`echo '$''{'ac_cv_lbl_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lnsl  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1406 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char gethostbyname();
+
+int main() {
+gethostbyname()
+; return 0; }
+EOF
+if { (eval echo configure:1417: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lbl_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lbl_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lbl_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo nsl | sed -e 's/^a-zA-Z0-9_/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lnsl $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+# Some strange OSes (SINIX) have it in libsocket:
+	    echo $ac_n "checking for gethostbyname in -lsocket""... $ac_c" 1>&6
+echo "configure:1444: checking for gethostbyname in -lsocket" >&5
+ac_lib_var=`echo socket'_'gethostbyname'_' | sed 'y%./+- %__p__%'`
+if eval "test \"`echo '$''{'ac_cv_lbl_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lsocket  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1452 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char gethostbyname();
+
+int main() {
+gethostbyname()
+; return 0; }
+EOF
+if { (eval echo configure:1463: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lbl_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lbl_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lbl_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo socket | sed -e 's/^a-zA-Z0-9_/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lsocket $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+# Unfortunately libsocket sometimes depends on libnsl.
+		# AC_CHECK_LIB's API is essentially broken so the
+		# following ugliness is necessary:
+		echo $ac_n "checking for gethostbyname in -lsocket""... $ac_c" 1>&6
+echo "configure:1492: checking for gethostbyname in -lsocket" >&5
+ac_lib_var=`echo socket'_'gethostbyname'_'-lnsl | sed 'y%./+- %__p__%'`
+if eval "test \"`echo '$''{'ac_cv_lbl_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lsocket -lnsl $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1500 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char gethostbyname();
+
+int main() {
+gethostbyname()
+; return 0; }
+EOF
+if { (eval echo configure:1511: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lbl_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lbl_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lbl_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  LIBS="-lsocket -lnsl $LIBS"
+else
+  echo "$ac_t""no" 1>&6
+echo $ac_n "checking for gethostbyname in -lresolv""... $ac_c" 1>&6
+echo "configure:1530: checking for gethostbyname in -lresolv" >&5
+ac_lib_var=`echo resolv'_'gethostbyname | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lresolv  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1538 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char gethostbyname();
+
+int main() {
+gethostbyname()
+; return 0; }
+EOF
+if { (eval echo configure:1549: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo resolv | sed -e 's/^a-zA-Z0-9_/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lresolv $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+fi
+
+fi
+
+fi
+
+fi
+
+    echo $ac_n "checking for socket""... $ac_c" 1>&6
+echo "configure:1585: checking for socket" >&5
+if eval "test \"`echo '$''{'ac_cv_func_socket'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1590 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char socket(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char socket();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_socket) || defined (__stub___socket)
+choke me
+#else
+socket();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:1613: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_socket=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_socket=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'socket`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  :
+else
+  echo "$ac_t""no" 1>&6
+echo $ac_n "checking for socket in -lsocket""... $ac_c" 1>&6
+echo "configure:1631: checking for socket in -lsocket" >&5
+ac_lib_var=`echo socket'_'socket | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lsocket  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1639 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char socket();
+
+int main() {
+socket()
+; return 0; }
+EOF
+if { (eval echo configure:1650: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo socket | sed -e 's/^a-zA-Z0-9_/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lsocket $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+echo $ac_n "checking for socket in -lsocket""... $ac_c" 1>&6
+echo "configure:1676: checking for socket in -lsocket" >&5
+ac_lib_var=`echo socket'_'socket'_'-lnsl | sed 'y%./+- %__p__%'`
+if eval "test \"`echo '$''{'ac_cv_lbl_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lsocket -lnsl $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1684 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char socket();
+
+int main() {
+socket()
+; return 0; }
+EOF
+if { (eval echo configure:1695: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lbl_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lbl_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lbl_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  LIBS="-lsocket -lnsl $LIBS"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+fi
+
+fi
+
+    # DLPI needs putmsg under HPUX so test for -lstr while we're at it
+    echo $ac_n "checking for putmsg in -lstr""... $ac_c" 1>&6
+echo "configure:1721: checking for putmsg in -lstr" >&5
+ac_lib_var=`echo str'_'putmsg | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lstr  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1729 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char putmsg();
+
+int main() {
+putmsg()
+; return 0; }
+EOF
+if { (eval echo configure:1740: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo str | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lstr $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+    
+
+case "$target_os" in
+
+bsd4*)
+	cat >> confdefs.h <<\EOF
+#define HAVE_RAW_OPTIONS 1
+EOF
+
+	;;
+
+bsdi*)
+	cat >> confdefs.h <<\EOF
+#define HAVE_RAW_OPTIONS 1
+EOF
+
+	;;
+
+freebsd*)
+	cat >> confdefs.h <<\EOF
+#define HAVE_RAW_OPTIONS 1
+EOF
+
+	;;
+
+linux*)
+	V_INCLS="$V_INCLS -Ilinux-include -DHAVE_IFF_LOOPBACK -DUSE_KERNEL_ROUTING_TABLE"
+	cat >> confdefs.h <<\EOF
+#define BYTESWAP_IP_HDR 1
+EOF
+
+	;;
+
+osf3*)
+		cat >> confdefs.h <<\EOF
+#define __STDC__ 2
+EOF
+
+	;;
+
+solaris2.[012345]*)
+	cat >> confdefs.h <<\EOF
+#define BYTESWAP_IP_HDR 1
+EOF
+
+	cat >> confdefs.h <<\EOF
+#define CANT_HACK_IPCKSUM 1
+EOF
+
+	;;
+
+solaris*)
+	cat >> confdefs.h <<\EOF
+#define BYTESWAP_IP_HDR 1
+EOF
+
+	;;
+esac
+
+echo $ac_n "checking routing table type""... $ac_c" 1>&6
+echo "configure:1827: checking routing table type" >&5
+t="generic"
+if test $ac_cv_header_inet_mib2_h = yes ; then
+	t="mib"
+elif test $ac_cv_header_net_route_h = yes -a \
+    $ac_cv_header_net_if_dl_h = yes ; then
+	t="socket"
+elif test -f /proc/net/route ; then
+	t="linux"
+fi
+
+echo "$ac_t""${t}" 1>&6
+V_FINDSADDR="findsaddr-${t}.c"
+
+
+echo $ac_n "checking for int32_t using $CC""... $ac_c" 1>&6
+echo "configure:1843: checking for int32_t using $CC" >&5
+    if eval "test \"`echo '$''{'ac_cv_lbl_have_int32_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1848 "configure"
+#include "confdefs.h"
+
+#	include "confdefs.h"
+#	include <sys/types.h>
+#	if STDC_HEADERS
+#	include <stdlib.h>
+#	include <stddef.h>
+#	endif
+int main() {
+int32_t i
+; return 0; }
+EOF
+if { (eval echo configure:1861: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_lbl_have_int32_t=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_lbl_have_int32_t=no
+fi
+rm -f conftest*
+fi
+
+    echo "$ac_t""$ac_cv_lbl_have_int32_t" 1>&6
+    if test $ac_cv_lbl_have_int32_t = no ; then
+	    cat >> confdefs.h <<\EOF
+#define int32_t int
+EOF
+
+    fi
+echo $ac_n "checking for u_int32_t using $CC""... $ac_c" 1>&6
+echo "configure:1881: checking for u_int32_t using $CC" >&5
+    if eval "test \"`echo '$''{'ac_cv_lbl_have_u_int32_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1886 "configure"
+#include "confdefs.h"
+
+#	include "confdefs.h"
+#	include <sys/types.h>
+#	if STDC_HEADERS
+#	include <stdlib.h>
+#	include <stddef.h>
+#	endif
+int main() {
+u_int32_t i
+; return 0; }
+EOF
+if { (eval echo configure:1899: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_lbl_have_u_int32_t=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_lbl_have_u_int32_t=no
+fi
+rm -f conftest*
+fi
+
+    echo "$ac_t""$ac_cv_lbl_have_u_int32_t" 1>&6
+    if test $ac_cv_lbl_have_u_int32_t = no ; then
+	    cat >> confdefs.h <<\EOF
+#define u_int32_t u_int
+EOF
+
+    fi
+
+rm -f os-proto.h
+    if test "${LBL_CFLAGS+set}" = set; then
+	    V_CCOPT="$V_CCOPT ${LBL_CFLAGS}"
+    fi
+    if test -f .devel ; then
+	     if test "$GCC" = yes ; then
+	    if test "$SHLICC2" = yes ; then
+		    ac_cv_lbl_gcc_vers=2
+		    V_CCOPT="`echo $V_CCOPT | sed -e 's/-O/-O2/'`"
+	    else
+		    echo $ac_n "checking gcc version""... $ac_c" 1>&6
+echo "configure:1930: checking gcc version" >&5
+		    if eval "test \"`echo '$''{'ac_cv_lbl_gcc_vers'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_cv_lbl_gcc_vers=`$CC --version 2>&1 | \
+			    sed -e 's/\..*//'`
+fi
+
+		    # XXX hack for Red Hat linux
+		    ac_cv_lbl_gcc_vers=2
+
+		    echo "$ac_t""$ac_cv_lbl_gcc_vers" 1>&6
+		    if test $ac_cv_lbl_gcc_vers -gt 1 ; then
+			    V_CCOPT="`echo $V_CCOPT | sed -e 's/-O/-O2/'`"
+		    fi
+	    fi
+	    if test "${LBL_CFLAGS+set}" != set; then
+		    if test "$ac_cv_prog_cc_g" = yes ; then
+			    V_CCOPT="-g $V_CCOPT"
+		    fi
+		    V_CCOPT="$V_CCOPT -Wall"
+		    if test $ac_cv_lbl_gcc_vers -gt 1 ; then
+			    V_CCOPT="$V_CCOPT -Wmissing-prototypes -Wstrict-prototypes"
+		    fi
+	    fi
+    else
+	    case "$target_os" in
+
+	    irix6*)
+		    V_CCOPT="$V_CCOPT -fullwarn -n32"
+		    ;;
+
+	    *)
+		    ;;
+	    esac
+    fi
+	    os=`echo $target_os | sed -e 's/\([0-9][0-9]*\)[^0-9].*$/\1/'`
+	    name="lbl/os-$os.h"
+	    if test -f $name ; then
+		    ln -s $name os-proto.h
+		    cat >> confdefs.h <<\EOF
+#define HAVE_OS_PROTO_H 1
+EOF
+
+	    else
+		    echo "configure: warning: can't find $name" 1>&2
+	    fi
+    fi
+
+echo $ac_n "checking if sockaddr struct has sa_len member""... $ac_c" 1>&6
+echo "configure:1977: checking if sockaddr struct has sa_len member" >&5
+    if eval "test \"`echo '$''{'ac_cv_lbl_sockaddr_has_sa_len'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1982 "configure"
+#include "confdefs.h"
+
+#	include <sys/types.h>
+#	include <sys/socket.h>
+int main() {
+u_int i = sizeof(((struct sockaddr *)0)->sa_len)
+; return 0; }
+EOF
+if { (eval echo configure:1991: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_lbl_sockaddr_has_sa_len=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_lbl_sockaddr_has_sa_len=no
+fi
+rm -f conftest*
+fi
+
+    echo "$ac_t""$ac_cv_lbl_sockaddr_has_sa_len" 1>&6
+    if test $ac_cv_lbl_sockaddr_has_sa_len = yes ; then
+	    cat >> confdefs.h <<\EOF
+#define HAVE_SOCKADDR_SA_LEN 1
+EOF
+
+    fi
+
+echo $ac_n "checking if struct icmp has icmp_nextmtu""... $ac_c" 1>&6
+echo "configure:2012: checking if struct icmp has icmp_nextmtu" >&5
+if eval "test \"`echo '$''{'ac_cv_struct_icmp_has_icmp_nextmtu'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  LBL_SAVE_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS $V_INCLS"
+    cat > conftest.$ac_ext <<EOF
+#line 2019 "configure"
+#include "confdefs.h"
+   
+#       include <sys/param.h>
+#	include <sys/socket.h>
+#	include <netinet/in_systm.h>
+#       if __STDC__
+        /* osf3 has REALLY good prototyes */
+        struct mbuf;
+        struct rtentry;
+#       endif
+#       include <netinet/in.h>
+#       include <netinet/ip.h>
+#       include <netinet/ip_icmp.h>
+#       include <netinet/if_ether.h>
+int main() {
+u_int i = sizeof(((struct icmp *)0)->icmp_nextmtu)
+; return 0; }
+EOF
+if { (eval echo configure:2038: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_struct_icmp_has_icmp_nextmtu=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_struct_icmp_has_icmp_nextmtu=no
+fi
+rm -f conftest*
+    CFLAGS="$LBL_SAVE_CFLAGS"
+fi
+
+echo "$ac_t""$ac_cv_struct_icmp_has_icmp_nextmtu" 1>&6
+if test $ac_cv_struct_icmp_has_icmp_nextmtu = yes ; then
+	cat >> confdefs.h <<\EOF
+#define HAVE_ICMP_NEXTMTU 1
+EOF
+
+fi
+
+if test "${srcdir}" = "." ; then
+	srcdirprefix=""
+else
+	srcdirprefix="./"
+fi
+
+if test -r ${srcdirprefix}lbl/gnuc.h ; then
+	rm -f gnuc.h
+	ln -s ${srcdirprefix}lbl/gnuc.h gnuc.h
+fi
+
+
+
+
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# ./install, which can be erroneously created by make from ./install.sh.
+echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
+echo "configure:2086: checking for a BSD compatible install" >&5
+if test -z "$INSTALL"; then
+if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS=":"
+  for ac_dir in $PATH; do
+    # Account for people who put trailing slashes in PATH elements.
+    case "$ac_dir/" in
+    /|./|.//|/etc/*|/usr/sbin/*|/usr/etc/*|/sbin/*|/usr/afsws/bin/*|/usr/ucb/*) ;;
+    *)
+      # OSF1 and SCO ODT 3.0 have their own names for install.
+      # Don't use installbsd from OSF since it installs stuff as root
+      # by default.
+      for ac_prog in ginstall scoinst install; do
+        if test -f $ac_dir/$ac_prog; then
+	  if test $ac_prog = install &&
+            grep dspmsg $ac_dir/$ac_prog >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  else
+	    ac_cv_path_install="$ac_dir/$ac_prog -c"
+	    break 2
+	  fi
+	fi
+      done
+      ;;
+    esac
+  done
+  IFS="$ac_save_IFS"
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL="$ac_cv_path_install"
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL="$ac_install_sh"
+  fi
+fi
+echo "$ac_t""$INSTALL" 1>&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+trap '' 1 2 15
+cat > confcache <<\EOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs.  It is not useful on other systems.
+# If it contains results you don't want to keep, you may remove or edit it.
+#
+# By default, configure uses ./config.cache as the cache file,
+# creating it if it does not exist already.  You can give configure
+# the --cache-file=FILE option to use a different cache file; that is
+# what configure does when it calls configure scripts in
+# subdirectories, so they share the cache.
+# Giving --cache-file=/dev/null disables caching, for debugging configure.
+# config.status only pays attention to the cache file if you give it the
+# --recheck option to rerun configure.
+#
+EOF
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(set) 2>&1 |
+  case `(ac_space=' '; set | grep ac_space) 2>&1` in
+  *ac_space=\ *)
+    # `set' does not quote correctly, so add quotes (double-quote substitution
+    # turns \\\\ into \\, and sed turns \\ into \).
+    sed -n \
+      -e "s/'/'\\\\''/g" \
+      -e "s/^\\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\\)=\\(.*\\)/\\1=\${\\1='\\2'}/p"
+    ;;
+  *)
+    # `set' quotes correctly as required by POSIX, so do not add quotes.
+    sed -n -e 's/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/\1=${\1=\2}/p'
+    ;;
+  esac >> confcache
+if cmp -s $cache_file confcache; then
+  :
+else
+  if test -w $cache_file; then
+    echo "updating cache $cache_file"
+    cat confcache > $cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# Any assignment to VPATH causes Sun make to only execute
+# the first set of double-colon rules, so remove it if not needed.
+# If there is a colon in the path, we need to keep it.
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
+fi
+
+trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15
+
+# Transform confdefs.h into DEFS.
+# Protect against shell expansion while executing Makefile rules.
+# Protect against Makefile macro expansion.
+cat > conftest.defs <<\EOF
+s%#define \([A-Za-z_][A-Za-z0-9_]*\) *\(.*\)%-D\1=\2%g
+s%[ 	`~#$^&*(){}\\|;'"<>?]%\\&%g
+s%\[%\\&%g
+s%\]%\\&%g
+s%\$%$$%g
+EOF
+DEFS=`sed -f conftest.defs confdefs.h | tr '\012' ' '`
+rm -f conftest.defs
+
+
+# Without the "./", some shells look in PATH for config.status.
+: ${CONFIG_STATUS=./config.status}
+
+echo creating $CONFIG_STATUS
+rm -f $CONFIG_STATUS
+cat > $CONFIG_STATUS <<EOF
+#! /bin/sh
+# Generated automatically by configure.
+# Run this file to recreate the current configuration.
+# This directory was configured as follows,
+# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+#
+# $0 $ac_configure_args
+#
+# Compiler output produced by configure, useful for debugging
+# configure, is in ./config.log if it exists.
+
+ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
+for ac_option
+do
+  case "\$ac_option" in
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
+    exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
+  -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
+    echo "$CONFIG_STATUS generated by autoconf version 2.13"
+    exit 0 ;;
+  -help | --help | --hel | --he | --h)
+    echo "\$ac_cs_usage"; exit 0 ;;
+  *) echo "\$ac_cs_usage"; exit 1 ;;
+  esac
+done
+
+ac_given_srcdir=$srcdir
+ac_given_INSTALL="$INSTALL"
+
+trap 'rm -fr `echo "Makefile" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
+EOF
+cat >> $CONFIG_STATUS <<EOF
+
+# Protect against being on the right side of a sed subst in config.status.
+sed 's/%@/@@/; s/@%/@@/; s/%g\$/@g/; /@g\$/s/[\\\\&%]/\\\\&/g;
+ s/@@/%@/; s/@@/@%/; s/@g\$/%g/' > conftest.subs <<\\CEOF
+$ac_vpsub
+$extrasub
+s%@SHELL@%$SHELL%g
+s%@CFLAGS@%$CFLAGS%g
+s%@CPPFLAGS@%$CPPFLAGS%g
+s%@CXXFLAGS@%$CXXFLAGS%g
+s%@FFLAGS@%$FFLAGS%g
+s%@DEFS@%$DEFS%g
+s%@LDFLAGS@%$LDFLAGS%g
+s%@LIBS@%$LIBS%g
+s%@exec_prefix@%$exec_prefix%g
+s%@prefix@%$prefix%g
+s%@program_transform_name@%$program_transform_name%g
+s%@bindir@%$bindir%g
+s%@sbindir@%$sbindir%g
+s%@libexecdir@%$libexecdir%g
+s%@datadir@%$datadir%g
+s%@sysconfdir@%$sysconfdir%g
+s%@sharedstatedir@%$sharedstatedir%g
+s%@localstatedir@%$localstatedir%g
+s%@libdir@%$libdir%g
+s%@includedir@%$includedir%g
+s%@oldincludedir@%$oldincludedir%g
+s%@infodir@%$infodir%g
+s%@mandir@%$mandir%g
+s%@host@%$host%g
+s%@host_alias@%$host_alias%g
+s%@host_cpu@%$host_cpu%g
+s%@host_vendor@%$host_vendor%g
+s%@host_os@%$host_os%g
+s%@target@%$target%g
+s%@target_alias@%$target_alias%g
+s%@target_cpu@%$target_cpu%g
+s%@target_vendor@%$target_vendor%g
+s%@target_os@%$target_os%g
+s%@build@%$build%g
+s%@build_alias@%$build_alias%g
+s%@build_cpu@%$build_cpu%g
+s%@build_vendor@%$build_vendor%g
+s%@build_os@%$build_os%g
+s%@SHLICC2@%$SHLICC2%g
+s%@CC@%$CC%g
+s%@CPP@%$CPP%g
+s%@LIBOBJS@%$LIBOBJS%g
+s%@V_CCOPT@%$V_CCOPT%g
+s%@V_INCLS@%$V_INCLS%g
+s%@V_FINDSADDR@%$V_FINDSADDR%g
+s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
+s%@INSTALL_SCRIPT@%$INSTALL_SCRIPT%g
+s%@INSTALL_DATA@%$INSTALL_DATA%g
+
+CEOF
+EOF
+
+cat >> $CONFIG_STATUS <<\EOF
+
+# Split the substitutions into bite-sized pieces for seds with
+# small command number limits, like on Digital OSF/1 and HP-UX.
+ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.
+ac_file=1 # Number of current file.
+ac_beg=1 # First line for current file.
+ac_end=$ac_max_sed_cmds # Line after last line for current file.
+ac_more_lines=:
+ac_sed_cmds=""
+while $ac_more_lines; do
+  if test $ac_beg -gt 1 ; then
+    sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
+  else
+    sed "${ac_end}q" conftest.subs > conftest.s$ac_file
+  fi
+  if test ! -s conftest.s$ac_file; then
+    ac_more_lines=false
+    rm -f conftest.s$ac_file
+  else
+    if test -z "$ac_sed_cmds"; then
+      ac_sed_cmds="sed -f conftest.s$ac_file"
+    else
+      ac_sed_cmds="$ac_sed_cmds | sed -f conftest.s$ac_file"
+    fi
+    ac_file=`expr $ac_file + 1`
+    ac_beg=$ac_end
+    ac_end=`expr $ac_end + $ac_max_sed_cmds`
+  fi
+done
+if test -z "$ac_sed_cmds"; then
+  ac_sed_cmds=cat
+fi
+EOF
+
+cat >> $CONFIG_STATUS <<EOF
+
+CONFIG_FILES=\${CONFIG_FILES-"Makefile"}
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case "$ac_file" in
+  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+  *) ac_file_in="${ac_file}.in" ;;
+  esac
+
+  # Adjust a relative srcdir, top_srcdir, and INSTALL for subdirectories.
+
+  # Remove last slash and all that follows it.  Not all systems have dirname.
+  ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+  if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+    # The file is in a subdirectory.
+    test ! -d "$ac_dir" && mkdir "$ac_dir"
+    ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
+    # A "../" for each directory in $ac_dir_suffix.
+    ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
+  else
+    ac_dir_suffix= ac_dots=
+  fi
+
+  case "$ac_given_srcdir" in
+  .)  srcdir=.
+      if test -z "$ac_dots"; then top_srcdir=.
+      else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
+  /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
+  *) # Relative path.
+    srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
+    top_srcdir="$ac_dots$ac_given_srcdir" ;;
+  esac
+
+  case "$ac_given_INSTALL" in
+  [/$]*) INSTALL="$ac_given_INSTALL" ;;
+  *) INSTALL="$ac_dots$ac_given_INSTALL" ;;
+  esac
+
+  echo creating "$ac_file"
+  rm -f "$ac_file"
+  configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
+  case "$ac_file" in
+  *Makefile*) ac_comsub="1i\\
+# $configure_input" ;;
+  *) ac_comsub= ;;
+  esac
+
+  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+  sed -e "$ac_comsub
+s%@configure_input@%$configure_input%g
+s%@srcdir@%$srcdir%g
+s%@top_srcdir@%$top_srcdir%g
+s%@INSTALL@%$INSTALL%g
+" $ac_file_inputs | (eval "$ac_sed_cmds") > $ac_file
+fi; done
+rm -f conftest.s*
+
+EOF
+cat >> $CONFIG_STATUS <<EOF
+
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+
+exit 0
+EOF
+chmod +x $CONFIG_STATUS
+rm -fr confdefs* $ac_clean_files
+test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1
+
+
+if test -f .devel ; then
+	make depend
+fi
+
+exit 0
diff -Nurb traceroute-1.4a12.old/ifaddrlist.c traceroute-1.4a12/ifaddrlist.c
--- traceroute-1.4a12.old/ifaddrlist.c	2000-11-23 20:02:06.000000000 +0000
+++ traceroute-1.4a12/ifaddrlist.c	2004-08-16 13:11:06.000000000 +0100
@@ -169,6 +169,15 @@
 		}
 		sin = (struct sockaddr_in *)&ifr.ifr_addr;
 		al->addr = sin->sin_addr.s_addr;
+		if (ioctl(fd, SIOCGIFNETMASK, (char *)&ifr) < 0) {
+			(void)sprintf(errbuf, "SIOCGIFNETMASK: %s: %s",
+			    device, strerror(errno));
+			(void)close(fd);
+			return (-1);
+		}
+
+		sin = (struct sockaddr_in *)&ifr.ifr_netmask;
+		al->mask = sin->sin_addr.s_addr;
 		al->device = strdup(device);
 		++al;
 		++nipaddr;
diff -Nurb traceroute-1.4a12.old/ifaddrlist.c.orig traceroute-1.4a12/ifaddrlist.c.orig
--- traceroute-1.4a12.old/ifaddrlist.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ traceroute-1.4a12/ifaddrlist.c.orig	2000-11-23 20:02:06.000000000 +0000
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) 1997, 1998, 1999, 2000
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef lint
+static const char rcsid[] =
+    "@(#) $Id: traceroute-1.4a12-fc2.patch,v 1.1 2004/08/16 12:48:24 lawrence Exp $ (LBL)";
+#endif
+
+#include <sys/param.h>
+#include <sys/file.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_SOCKIO_H
+#include <sys/sockio.h>
+#endif
+#include <sys/time.h>				/* concession to AIX */
+
+#if __STDC__
+struct mbuf;
+struct rtentry;
+#endif
+
+#include <net/if.h>
+#include <netinet/in.h>
+
+#include <ctype.h>
+#include <errno.h>
+#include <memory.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "gnuc.h"
+#ifdef HAVE_OS_PROTO_H
+#include "os-proto.h"
+#endif
+
+#include "ifaddrlist.h"
+
+/*
+ * Return the interface list
+ */
+int
+ifaddrlist(register struct ifaddrlist **ipaddrp, register char *errbuf)
+{
+	register int fd, nipaddr;
+#ifdef HAVE_SOCKADDR_SA_LEN
+	register int n;
+#endif
+	register struct ifreq *ifrp, *ifend, *ifnext, *mp;
+	register struct sockaddr_in *sin;
+	register struct ifaddrlist *al;
+	struct ifconf ifc;
+	struct ifreq ibuf[(32 * 1024) / sizeof(struct ifreq)], ifr;
+#define MAX_IPADDR (sizeof(ibuf) / sizeof(ibuf[0]))
+	static struct ifaddrlist ifaddrlist[MAX_IPADDR];
+	char device[sizeof(ifr.ifr_name) + 1];
+
+	fd = socket(AF_INET, SOCK_DGRAM, 0);
+	if (fd < 0) {
+		(void)sprintf(errbuf, "socket: %s", strerror(errno));
+		return (-1);
+	}
+	ifc.ifc_len = sizeof(ibuf);
+	ifc.ifc_buf = (caddr_t)ibuf;
+
+	if (ioctl(fd, SIOCGIFCONF, (char *)&ifc) < 0 ||
+	    ifc.ifc_len < sizeof(struct ifreq)) {
+		if (errno == EINVAL)
+			(void)sprintf(errbuf,
+			    "SIOCGIFCONF: ifreq struct too small (%d bytes)",
+			    sizeof(ibuf));
+		else
+			(void)sprintf(errbuf, "SIOCGIFCONF: %s",
+			    strerror(errno));
+		(void)close(fd);
+		return (-1);
+	}
+	ifrp = ibuf;
+	ifend = (struct ifreq *)((char *)ibuf + ifc.ifc_len);
+
+	al = ifaddrlist;
+	mp = NULL;
+	nipaddr = 0;
+	for (; ifrp < ifend; ifrp = ifnext) {
+#ifdef HAVE_SOCKADDR_SA_LEN
+		n = ifrp->ifr_addr.sa_len + sizeof(ifrp->ifr_name);
+		if (n < sizeof(*ifrp))
+			ifnext = ifrp + 1;
+		else
+			ifnext = (struct ifreq *)((char *)ifrp + n);
+		if (ifrp->ifr_addr.sa_family != AF_INET)
+			continue;
+#else
+		ifnext = ifrp + 1;
+#endif
+		/*
+		 * Need a template to preserve address info that is
+		 * used below to locate the next entry.  (Otherwise,
+		 * SIOCGIFFLAGS stomps over it because the requests
+		 * are returned in a union.)
+		 */
+		strncpy(ifr.ifr_name, ifrp->ifr_name, sizeof(ifr.ifr_name));
+		if (ioctl(fd, SIOCGIFFLAGS, (char *)&ifr) < 0) {
+			if (errno == ENXIO)
+				continue;
+			(void)sprintf(errbuf, "SIOCGIFFLAGS: %.*s: %s",
+			    (int)sizeof(ifr.ifr_name), ifr.ifr_name,
+			    strerror(errno));
+			(void)close(fd);
+			return (-1);
+		}
+
+		/* Must be up */
+		if ((ifr.ifr_flags & IFF_UP) == 0)
+			continue;
+
+
+		(void)strncpy(device, ifr.ifr_name, sizeof(ifr.ifr_name));
+		device[sizeof(device) - 1] = '\0';
+#ifdef sun
+		/* Ignore sun virtual interfaces */
+		if (strchr(device, ':') != NULL)
+			continue;
+#endif
+		if (ioctl(fd, SIOCGIFADDR, (char *)&ifr) < 0) {
+			(void)sprintf(errbuf, "SIOCGIFADDR: %s: %s",
+			    device, strerror(errno));
+			(void)close(fd);
+			return (-1);
+		}
+
+		if (nipaddr >= MAX_IPADDR) {
+			(void)sprintf(errbuf, "Too many interfaces (%d)",
+			    MAX_IPADDR);
+			(void)close(fd);
+			return (-1);
+		}
+		sin = (struct sockaddr_in *)&ifr.ifr_addr;
+		al->addr = sin->sin_addr.s_addr;
+		al->device = strdup(device);
+		++al;
+		++nipaddr;
+	}
+	(void)close(fd);
+
+	*ipaddrp = ifaddrlist;
+	return (nipaddr);
+}
diff -Nurb traceroute-1.4a12.old/ifaddrlist.h traceroute-1.4a12/ifaddrlist.h
--- traceroute-1.4a12.old/ifaddrlist.h	1997-04-22 21:15:51.000000000 +0100
+++ traceroute-1.4a12/ifaddrlist.h	2004-08-16 13:11:06.000000000 +0100
@@ -23,6 +23,7 @@
 
 struct ifaddrlist {
 	u_int32_t addr;
+	u_int32_t mask;
 	char *device;
 };
 
diff -Nurb traceroute-1.4a12.old/ifaddrlist.h.orig traceroute-1.4a12/ifaddrlist.h.orig
--- traceroute-1.4a12.old/ifaddrlist.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ traceroute-1.4a12/ifaddrlist.h.orig	1997-04-22 21:15:51.000000000 +0100
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 1997
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code distributions
+ * retain the above copyright notice and this paragraph in its entirety, (2)
+ * distributions including binary code include the above copyright notice and
+ * this paragraph in its entirety in the documentation or other materials
+ * provided with the distribution, and (3) all advertising materials mentioning
+ * features or use of this software display the following acknowledgement:
+ * ``This product includes software developed by the University of California,
+ * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+ * the University nor the names of its contributors may be used to endorse
+ * or promote products derived from this software without specific prior
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * @(#) $Header: /global/projects/repository/smoothwallcore/distrib/build/sources/traceroute/traceroute-1.4a12-fc2.patch,v 1.1 2004/08/16 12:48:24 lawrence Exp $ (LBL)
+ */
+
+struct ifaddrlist {
+	u_int32_t addr;
+	char *device;
+};
+
+int	ifaddrlist(struct ifaddrlist **, char *);
diff -Nurb traceroute-1.4a12.old/Makefile.in traceroute-1.4a12/Makefile.in
--- traceroute-1.4a12.old/Makefile.in	2000-11-23 20:05:29.000000000 +0000
+++ traceroute-1.4a12/Makefile.in	2004-08-16 13:11:06.000000000 +0100
@@ -27,9 +27,9 @@
 prefix = @prefix@
 exec_prefix = @exec_prefix@
 # Pathname of directory to install the binary
-BINDEST = @sbindir@
+sbindir = @sbindir@
 # Pathname of directory to install the man page
-MANDEST = @mandir@
+mandir = @mandir@
 
 # VPATH
 srcdir = @srcdir@
@@ -90,10 +90,10 @@
 	sed -e 's/.*/char version[] = "&";/' $(srcdir)/VERSION > $@
 
 install: force
-	$(INSTALL) -m 4555 -o root -g bin traceroute $(DESTDIR)$(BINDEST)
+	$(INSTALL) -m 4755 traceroute $(DESTDIR)/bin
 
 install-man: force
-	$(INSTALL) -m 444 -o bin -g bin traceroute.8 $(DESTDIR)$(MANDEST)/man8
+	$(INSTALL) traceroute.8 $(DESTDIR)$(mandir)/man8
 
 lint: $(GENSRC) force
 	lint -hbxn $(SRC) | \
diff -Nurb traceroute-1.4a12.old/Makefile.in.orig traceroute-1.4a12/Makefile.in.orig
--- traceroute-1.4a12.old/Makefile.in.orig	1970-01-01 01:00:00.000000000 +0100
+++ traceroute-1.4a12/Makefile.in.orig	2004-08-16 13:11:06.000000000 +0100
@@ -0,0 +1,129 @@
+#  Copyright (c) 1988, 1989, 1990, 1991, 1992, 1995, 1996, 1997, 1998, 1999, 2000
+# 	The Regents of the University of California.  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that: (1) source code distributions
+#  retain the above copyright notice and this paragraph in its entirety, (2)
+#  distributions including binary code include the above copyright notice and
+#  this paragraph in its entirety in the documentation or other materials
+#  provided with the distribution, and (3) all advertising materials mentioning
+#  features or use of this software display the following acknowledgement:
+#  ``This product includes software developed by the University of California,
+#  Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+#  the University nor the names of its contributors may be used to endorse
+#  or promote products derived from this software without specific prior
+#  written permission.
+#  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+#  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+#
+# @(#) $Id: traceroute-1.4a12-fc2.patch,v 1.1 2004/08/16 12:48:24 lawrence Exp $ (LBL)
+
+#
+# Various configurable paths (remember to edit Makefile.in, not Makefile)
+#
+
+# Top level hierarchy
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+# Pathname of directory to install the binary
+BINDEST = @sbindir@
+# Pathname of directory to install the man page
+MANDEST = @mandir@
+
+# VPATH
+srcdir = @srcdir@
+VPATH = @srcdir@
+
+#
+# You shouldn't need to edit anything below here.
+#
+
+CC = @CC@
+CCOPT = @V_CCOPT@
+INCLS = -I. @V_INCLS@
+DEFS = @DEFS@
+
+# Standard CFLAGS
+CFLAGS = $(CCOPT) $(DEFS) $(INCLS)
+
+# Standard LIBS
+LIBS = @LIBS@
+
+INSTALL = @INSTALL@
+
+# Explicitly define compilation rule since SunOS 4's make doesn't like gcc.
+# Also, gcc does not remove the .o before forking 'as', which can be a
+# problem if you don't own the file but can write to the directory.
+.c.o:
+	@rm -f $@
+	$(CC) $(CFLAGS) -c $(srcdir)/$*.c
+
+CSRC =	traceroute.c ifaddrlist.c @V_FINDSADDR@
+GENSRC = version.c
+
+SRC =	$(CSRC) $(GENSRC)
+HDR =	findsaddr.h ifaddrlist.h
+
+TAGHDR = \
+	/usr/include/netinet/in.h \
+	/usr/include/netinet/ip_icmp.h \
+	/usr/include/netinet/udp.h
+
+TAGFILES = $(SRC) $(HDR) $(TAGHDR)
+
+# We would like to say "OBJ = $(SRC:.c=.o)" but Ultrix's make cannot
+# hack the extra indirection
+OBJ =	$(CSRC:.c=.o) $(GENSRC:.c=.o) @LIBOBJS@
+
+CLEANFILES = $(OBJ) traceroute $(GENSRC)
+
+all: traceroute
+
+traceroute: $(OBJ)
+	@rm -f $@
+	$(CC) $(CFLAGS) -o $@ $(OBJ) $(LIBS)
+
+version.o: version.c
+version.c: $(srcdir)/VERSION
+	@rm -f $@
+	sed -e 's/.*/char version[] = "&";/' $(srcdir)/VERSION > $@
+
+install: force
+	$(INSTALL) -m 4755 traceroute $(DESTDIR)$(BINDEST)
+
+install-man: force
+	$(INSTALL) traceroute.8 $(DESTDIR)$(MANDEST)/man8
+
+lint: $(GENSRC) force
+	lint -hbxn $(SRC) | \
+	    grep -v 'struct/union .* never defined' | \
+	    grep -v 'possible pointer alignment problem'
+
+clean: force
+	rm -f $(CLEANFILES)
+
+distclean: force
+	rm -f $(CLEANFILES) Makefile config.cache config.log config.status \
+	    gnuc.h os-proto.h
+
+tags: $(TAGFILES)
+	ctags -wtd $(TAGFILES)
+
+tar: force
+	@cwd=`pwd` ; name=traceroute-`cat VERSION` ; \
+	    list="" ; tar="tar chf" ; temp="$$name.tar.gz" ; \
+	    for i in `cat FILES` ; do list="$$list $$name/$$i" ; done; \
+	    echo \
+	    "rm -f $$name; ln -s . $$name" ; \
+	     rm -f $$name; ln -s . $$name ; \
+	    echo \
+	    "$$tar - [lots of files] | gzip > $$temp" ; \
+	     $$tar - $$list | gzip > $$temp ; \
+	    echo \
+	    "rm -f $$name" ; \
+	     rm -f $$name
+
+force: /tmp
+depend: $(GENSRC) force
+	./mkdep -c $(CC) $(DEFS) $(INCLS) $(SRC)
diff -Nurb traceroute-1.4a12.old/traceroute.8 traceroute-1.4a12/traceroute.8
--- traceroute-1.4a12.old/traceroute.8	2000-09-21 09:44:24.000000000 +0100
+++ traceroute-1.4a12/traceroute.8	2004-08-16 13:11:06.000000000 +0100
@@ -168,7 +168,9 @@
 (low delay) and
 .RB ` -t
 .IR 8 '
-(high throughput).
+(high throughput).  If TOS value is changed by intermediate routers,
+(TOS=<value>!) will be printed once: value is the decimal value of the changed
+TOS byte.
 .TP
 .B \-v
 Verbose output.  Received ICMP packets other than TIME_EXCEEDED and
@@ -333,6 +335,8 @@
 (source route failed),
 .B !F\-<pmtu>
 (fragmentation needed \- the RFC1191 Path MTU Discovery value is displayed),
+.B (TOS=<value>!)
+(TOS has been altered in the path to <value>),
 .B !X
 (communication administratively prohibited),
 .B !V
diff -Nurb traceroute-1.4a12.old/traceroute.8.orig traceroute-1.4a12/traceroute.8.orig
--- traceroute-1.4a12.old/traceroute.8.orig	1970-01-01 01:00:00.000000000 +0100
+++ traceroute-1.4a12/traceroute.8.orig	2000-09-21 09:44:24.000000000 +0100
@@ -0,0 +1,367 @@
+.\" Copyright (c) 1989, 1995, 1996, 1997, 1999, 2000
+.\"	The Regents of the University of California.  All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms are permitted
+.\" provided that the above copyright notice and this paragraph are
+.\" duplicated in all such forms and that any documentation,
+.\" advertising materials, and other materials related to such
+.\" distribution and use acknowledge that the software was developed
+.\" by the University of California, Berkeley.  The name of the
+.\" University may not be used to endorse or promote products derived
+.\" from this software without specific prior written permission.
+.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+.\" IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+.\" WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+.\"
+.\"	$Id: traceroute-1.4a12-fc2.patch,v 1.1 2004/08/16 12:48:24 lawrence Exp $
+.\"
+.TH TRACEROUTE 8 "21 September 2000"
+.UC 6
+.SH NAME
+traceroute \- print the route packets take to network host
+.SH SYNOPSIS
+.na
+.B traceroute
+[
+.B \-dFInrvx
+] [
+.B \-f
+.I first_ttl
+] [
+.B \-g
+.I gateway
+]
+.br
+.ti +8
+[
+.B \-i
+.I iface
+] [
+.B \-m
+max_ttl
+] [
+.B \-p
+.I port
+]
+.br
+.ti +8
+[
+.B \-q
+.I nqueries
+] [
+.B \-s
+.I src_addr
+] [
+.B \-t
+.I tos
+]
+.br
+.ti +8
+[
+.B \-w
+.I waittime
+] [
+.B \-z
+.I pausemsecs
+]
+.br
+.ti +8
+.I host
+[
+.I packetlen
+]
+.ad
+.SH DESCRIPTION
+The Internet is a large and complex aggregation of
+network hardware, connected together by gateways.
+Tracking the route one's packets follow (or finding the miscreant
+gateway that's discarding your packets) can be difficult.
+.I Traceroute
+utilizes the IP protocol `time to live' field and attempts to elicit an
+ICMP TIME_EXCEEDED response from each gateway along the path to some
+host.
+.PP
+The only mandatory parameter is the destination host name or IP number.
+The default probe datagram length is 40 bytes, but this may be increased
+by specifying a packet length (in bytes) after the destination host
+name.
+.PP
+Other options are:
+.TP
+.B \-f
+Set the initial time-to-live used in the first outgoing probe packet.
+.TP
+.B \-F
+Set the "don't fragment" bit.
+.TP
+.B \-d
+Enable socket level debugging.
+.TP
+.B \-g
+Specify a loose source route gateway (8 maximum).
+.TP
+.B \-i
+Specify a network interface to obtain the source IP address for
+outgoing probe packets. This is normally only useful on a multi-homed
+host. (See the
+.B \-s
+flag for another way to do this.)
+.TP
+.B \-I
+Use ICMP ECHO instead of UDP datagrams.
+.TP
+.B \-m
+Set the max time-to-live (max number of hops) used in outgoing probe
+packets.  The default is 30 hops (the same default used for TCP
+connections).
+.TP
+.B \-n
+Print hop addresses numerically rather than symbolically and numerically
+(saves a nameserver address-to-name lookup for each gateway found on the
+path).
+.TP
+.B \-p
+Set the base UDP port number used in probes (default is 33434).
+Traceroute hopes that nothing is listening on UDP ports
+.I base
+to
+.I base + nhops - 1
+at the destination host (so an ICMP PORT_UNREACHABLE message will
+be returned to terminate the route tracing).  If something is
+listening on a port in the default range, this option can be used
+to pick an unused port range.
+.TP
+.B \-r
+Bypass the normal routing tables and send directly to a host on an attached
+network.
+If the host is not on a directly-attached network,
+an error is returned.
+This option can be used to ping a local host through an interface
+that has no route through it (e.g., after the interface was dropped by
+.IR routed (8C)).
+.TP
+.B \-s
+Use the following IP address (which usually is given as an IP number, not
+a hostname) as the source address in outgoing probe packets.  On
+multi-homed hosts (those with more than one IP
+address), this option can be used to
+force the source address to be something other than the IP address
+of the interface the probe packet is sent on.  If the IP address
+is not one of this machine's interface addresses, an error is
+returned and nothing is sent. (See the
+.B \-i
+flag for another way to do this.)
+.TP
+.B \-t
+Set the
+.I type-of-service
+in probe packets to the following value (default zero).  The value must be
+a decimal integer in the range 0 to 255.  This option can be used to
+see if different types-of-service result in different paths.  (If you
+are not running 4.4bsd, this may be academic since the normal network
+services like telnet and ftp don't let you control the TOS).
+Not all values of TOS are legal or
+meaningful \- see the IP spec for definitions.  Useful values are
+probably
+.RB ` -t
+.IR 16 '
+(low delay) and
+.RB ` -t
+.IR 8 '
+(high throughput).
+.TP
+.B \-v
+Verbose output.  Received ICMP packets other than TIME_EXCEEDED and
+UNREACHABLEs are listed.
+.TP
+.B \-w
+Set the time (in seconds) to wait for a response to a probe (default 5
+sec.).
+.TP
+.B \-x
+Toggle ip checksums. Normally, this prevents traceroute from calculating
+ip checksums. In some cases, the operating system can overwrite parts of
+the outgoing packet but not recalculate the checksum (so in some cases
+the default is to not calculate checksums and using
+.B \-x
+causes them to be calcualted). Note that checksums are usually required
+for the last hop when using ICMP ECHO probes
+.RB ( \-I ).
+So they are always calculated when using ICMP.
+.TP
+.B \-z
+Set the time (in milliseconds) to pause between probes (default 0).
+Some systems such as Solaris and routers such as Ciscos rate limit
+icmp messages. A good value to use with this this is 500 (e.g. 1/2 second).
+.PP
+This program attempts to trace the route an IP packet would follow to some
+internet host by launching UDP probe
+packets with a small ttl (time to live) then listening for an
+ICMP "time exceeded" reply from a gateway.  We start our probes
+with a ttl of one and increase by one until we get an ICMP "port
+unreachable" (which means we got to "host") or hit a max (which
+defaults to 30 hops & can be changed with the
+.B \-m
+flag).  Three
+probes (change with
+.B \-q
+flag) are sent at each ttl setting and a
+line is printed showing the ttl, address of the gateway and
+round trip time of each probe.  If the probe answers come from
+different gateways, the address of each responding system will
+be printed.  If there is no response within a 5 sec. timeout
+interval (changed with the
+.B \-w
+flag), a "*" is printed for that
+probe.
+.PP
+We don't want the destination
+host to process the UDP probe packets so the destination port is set to an
+unlikely value (if some clod on the destination is using that
+value, it can be changed with the
+.B \-p
+flag).
+.PP
+A sample use and output might be:
+
+.RS
+.nf
+[yak 71]% traceroute nis.nsf.net.
+traceroute to nis.nsf.net (35.1.1.48), 30 hops max, 38 byte packet
+ 1  helios.ee.lbl.gov (128.3.112.1)  19 ms  19 ms  0 ms
+ 2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms
+ 3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms
+ 4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  39 ms
+ 5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  39 ms  39 ms  39 ms
+ 6  128.32.197.4 (128.32.197.4)  40 ms  59 ms  59 ms
+ 7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  59 ms
+ 8  129.140.70.13 (129.140.70.13)  99 ms  99 ms  80 ms
+ 9  129.140.71.6 (129.140.71.6)  139 ms  239 ms  319 ms
+10  129.140.81.7 (129.140.81.7)  220 ms  199 ms  199 ms
+11  nic.merit.edu (35.1.1.48)  239 ms  239 ms  239 ms
+.fi
+.RE
+
+Note that lines 2 & 3 are the same.  This is due to a buggy
+kernel on the 2nd hop system \- lbl-csam.arpa \- that forwards
+packets with a zero ttl (a bug in the distributed version
+of 4.3BSD).  Note that you have to guess what path
+the packets are taking cross-country since the NSFNet (129.140)
+doesn't supply address-to-name translations for its NSSes.
+.PP
+A more interesting example is:
+
+.RS
+.nf
+[yak 72]% traceroute allspice.lcs.mit.edu.
+traceroute to allspice.lcs.mit.edu (18.26.0.115), 30 hops max
+ 1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms
+ 2  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  19 ms  19 ms
+ 3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  19 ms
+ 4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  19 ms  39 ms  39 ms
+ 5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  20 ms  39 ms  39 ms
+ 6  128.32.197.4 (128.32.197.4)  59 ms  119 ms  39 ms
+ 7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  39 ms
+ 8  129.140.70.13 (129.140.70.13)  80 ms  79 ms  99 ms
+ 9  129.140.71.6 (129.140.71.6)  139 ms  139 ms  159 ms
+10  129.140.81.7 (129.140.81.7)  199 ms  180 ms  300 ms
+11  129.140.72.17 (129.140.72.17)  300 ms  239 ms  239 ms
+12  * * *
+13  128.121.54.72 (128.121.54.72)  259 ms  499 ms  279 ms
+14  * * *
+15  * * *
+16  * * *
+17  * * *
+18  ALLSPICE.LCS.MIT.EDU (18.26.0.115)  339 ms  279 ms  279 ms
+.fi
+.RE
+
+Note that the gateways 12, 14, 15, 16 & 17 hops away
+either don't send ICMP "time exceeded" messages or send them
+with a ttl too small to reach us.  14 \- 17 are running the
+MIT C Gateway code that doesn't send "time exceeded"s.  God
+only knows what's going on with 12.
+.PP
+The silent gateway 12 in the above may be the result of a bug in
+the 4.[23]BSD network code (and its derivatives):  4.x (x <= 3)
+sends an unreachable message using whatever ttl remains in the
+original datagram.  Since, for gateways, the remaining ttl is
+zero, the ICMP "time exceeded" is guaranteed to not make it back
+to us.  The behavior of this bug is slightly more interesting
+when it appears on the destination system:
+
+.RS
+.nf
+ 1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms
+ 2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  39 ms
+ 3  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  39 ms  19 ms
+ 4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  19 ms
+ 5  ccn-nerif35.Berkeley.EDU (128.32.168.35)  39 ms  39 ms  39 ms
+ 6  csgw.Berkeley.EDU (128.32.133.254)  39 ms  59 ms  39 ms
+ 7  * * *
+ 8  * * *
+ 9  * * *
+10  * * *
+11  * * *
+12  * * *
+13  rip.Berkeley.EDU (128.32.131.22)  59 ms !  39 ms !  39 ms !
+.fi
+.RE
+
+Notice that there are 12 "gateways" (13 is the final
+destination) and exactly the last half of them are "missing".
+What's really happening is that rip (a Sun-3 running Sun OS3.5)
+is using the ttl from our arriving datagram as the ttl in its
+ICMP reply.  So, the reply will time out on the return path
+(with no notice sent to anyone since ICMP's aren't sent for
+ICMP's) until we probe with a ttl that's at least twice the path
+length.  I.e., rip is really only 7 hops away.  A reply that
+returns with a ttl of 1 is a clue this problem exists.
+Traceroute prints a "!" after the time if the ttl is <= 1.
+Since vendors ship a lot of obsolete (DEC's Ultrix, Sun 3.x) or
+non-standard (HPUX) software, expect to see this problem
+frequently and/or take care picking the target host of your
+probes.
+
+Other possible annotations after the time are
+.BR !H ,
+.BR !N ,
+or
+.B !P
+(host, network or protocol unreachable),
+.B !S
+(source route failed),
+.B !F\-<pmtu>
+(fragmentation needed \- the RFC1191 Path MTU Discovery value is displayed),
+.B !X
+(communication administratively prohibited),
+.B !V
+(host precedence violation),
+.B !C
+(precedence cutoff in effect), or
+.B !<num>
+(ICMP unreachable code <num>).
+These are defined by RFC1812 (which supersedes RFC1716).
+If almost all the probes result in some kind of unreachable, traceroute
+will give up and exit.
+.PP
+This program is intended for use in network testing, measurement
+and management.
+It should be used primarily for manual fault isolation.
+Because of the load it could impose on the network, it is unwise to use
+.I traceroute
+during normal operations or from automated scripts.
+.SH SEE ALSO
+pathchar(8), netstat(1), ping(8)
+.SH AUTHOR
+Implemented by Van Jacobson from a suggestion by Steve Deering.  Debugged
+by a cast of thousands with particularly cogent suggestions or fixes from
+C. Philip Wood, Tim Seaver and Ken Adelman.
+.LP
+The current version is available via anonymous ftp:
+.LP
+.RS
+.I ftp://ftp.ee.lbl.gov/traceroute.tar.gz
+.RE
+.SH BUGS
+Please send bug reports to traceroute@ee.lbl.gov.
diff -Nurb traceroute-1.4a12.old/traceroute.c traceroute-1.4a12/traceroute.c
--- traceroute-1.4a12.old/traceroute.c	2000-12-14 08:04:50.000000000 +0000
+++ traceroute-1.4a12/traceroute.c	2004-08-16 13:11:06.000000000 +0100
@@ -207,6 +207,7 @@
 #include <sys/socket.h>
 #include <sys/time.h>
 
+#include <net/if.h>
 #include <netinet/in_systm.h>
 #include <netinet/in.h>
 #include <netinet/ip.h>
@@ -215,6 +216,8 @@
 #include <netinet/udp.h>
 #include <netinet/udp_var.h>
 
+#include <linux/sockios.h>
+
 #include <arpa/inet.h>
 
 #include <ctype.h>
@@ -230,6 +233,11 @@
 #include <string.h>
 #include <unistd.h>
 
+#ifdef  __linux__
+#include <linux/types.h>
+#include <linux/icmp.h>
+#endif
+
 #include "gnuc.h"
 #ifdef HAVE_OS_PROTO_H
 #include "os-proto.h"
@@ -254,7 +262,7 @@
 #define NGATEWAYS ((int)((MAX_IPOPTLEN - IPOPT_MINOFF - 1) / sizeof(u_int32_t)))
 
 #ifndef MAXHOSTNAMELEN
-#define MAXHOSTNAMELEN	64
+#define MAXHOSTNAMELEN	256
 #endif
 
 #define Fprintf (void)fprintf
@@ -271,7 +279,7 @@
 struct outdata {
 	u_char seq;		/* sequence number of this packet */
 	u_char ttl;		/* ttl packet left with */
-	struct timeval tv;	/* time packet left */
+	struct timeval tv __attribute__((packed)); /* time packet left */
 };
 
 #ifndef HAVE_ICMP_NEXTMTU
@@ -282,6 +290,55 @@
 };
 #endif
 
+/*
+ * Support for ICMP extensions
+ *
+ * http://www.ietf.org/proceedings/01aug/I-D/draft-ietf-mpls-icmp-02.txt
+ */
+#define ICMP_EXT_OFFSET    8 /* ICMP type, code, checksum, unused */ + \
+                         128 /* original datagram */
+#define ICMP_EXT_VERSION 2
+/*
+ * ICMP extensions, common header
+ */
+struct icmp_ext_cmn_hdr {
+#if BYTE_ORDER == BIG_ENDIAN
+       u_char   version:4;
+       u_char   reserved1:4;
+#else
+       u_char   reserved1:4;
+       u_char   version:4;
+#endif
+       u_char   reserved2;
+       u_short  checksum;
+};
+
+/*
+ * ICMP extensions, object header
+ */
+struct icmp_ext_obj_hdr {
+    u_short length;
+    u_char  class_num;
+#define MPLS_STACK_ENTRY_CLASS 1
+    u_char  c_type;
+#define MPLS_STACK_ENTRY_C_TYPE 1
+};
+
+struct mpls_header {
+#if BYTE_ORDER == BIG_ENDIAN
+    u_int32_t label:20;
+    u_char  exp:3;
+    u_char  s:1;
+    u_char  ttl:8;
+#else
+    u_char  ttl:8;
+    u_char  s:1;
+    u_char  exp:3;
+    u_int32_t label:20;
+#endif
+};
+
+
 u_char	packet[512];		/* last inbound (icmp) packet */
 
 struct ip *outip;		/* last output (udp) packet */
@@ -300,7 +357,10 @@
 struct sockaddr wherefrom;	/* Who we are */
 int packlen;			/* total length of packet */
 int minpacket;			/* min ip packet size */
-int maxpacket = 32 * 1024;	/* max ip packet size */
+#if !defined(IP_MAXPACKET)
+#define	IP_MAXPACKET	64 * 1024
+#endif
+int maxpacket = IP_MAXPACKET;	/* max ip packet size */
 int pmtu;			/* Path MTU Discovery (RFC1191) */
 u_int pausemsecs;
 
@@ -348,10 +408,23 @@
 void	tvsub(struct timeval *, struct timeval *);
 __dead	void usage(void);
 int	wait_for_reply(int, struct sockaddr_in *, const struct timeval *);
+void	decode_extensions(u_char *buf, int ip_len);
 #ifndef HAVE_USLEEP
 int	usleep(u_int);
 #endif
 
+#ifdef linux
+struct sockaddr_in *to = (struct sockaddr_in *)&whereto;
+#endif
+#ifndef LAUGHTER
+u_short uh_sport;
+#endif
+
+#ifdef USE_KERNEL_ROUTING_TABLE
+struct ifaddrlist *search_routing_table(struct sockaddr_in *to, struct ifaddrlist *al, int n);
+#endif
+
+
 int
 main(int argc, char **argv)
 {
@@ -361,16 +434,18 @@
 	register u_char *outp;
 	register u_int32_t *ap;
 	register struct sockaddr_in *from = (struct sockaddr_in *)&wherefrom;
+#ifndef	linux
 	register struct sockaddr_in *to = (struct sockaddr_in *)&whereto;
+#endif
 	register struct hostinfo *hi;
-	int on = 1;
 	register struct protoent *pe;
+	int on = 1;
 	register int ttl, probe, i;
 	register int seq = 0;
-	int tos = 0, settos = 0;
+	unsigned int tos = 0, previous_tos = 0, settos = 0;
 	register int lsrr = 0;
 	register u_short off = 0;
-	struct ifaddrlist *al;
+	struct ifaddrlist *al, *allist;
 	char errbuf[132];
 
 	if (argv[0] == NULL)
@@ -380,6 +455,40 @@
 	else
 		prog = argv[0];
 
+	cp = "icmp";
+	if ((pe = getprotobyname(cp)) == NULL) {
+		Fprintf(stderr, "%s: unknown protocol %s\n", prog, cp);
+		exit(1);
+	}
+
+	/* Insure the socket fds won't be 0, 1 or 2 */
+	if (open(devnull, O_RDONLY) < 0 ||
+	    open(devnull, O_RDONLY) < 0 ||
+	    open(devnull, O_RDONLY) < 0) {
+		Fprintf(stderr, "%s: open \"%s\": %s\n",
+		    prog, devnull, strerror(errno));
+		exit(1);
+	}
+	if ((s = socket(AF_INET, SOCK_RAW, pe->p_proto)) < 0) {
+		Fprintf(stderr, "%s: icmp socket: %s\n", prog, strerror(errno));
+		exit(1);
+	}
+
+#ifndef __hpux
+	sndsock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+#else
+	sndsock = socket(AF_INET, SOCK_RAW,
+	useicmp ? IPPROTO_ICMP : IPPROTO_UDP);
+#endif
+
+	if (sndsock < 0) {
+		Fprintf(stderr, "%s: raw socket: %s\n", prog, strerror(errno));
+		exit(1);
+	}
+
+	/* Revert to non-privileged user after opening sockets */
+	setuid(getuid());
+
 	opterr = 0;
 	while ((op = getopt(argc, argv, "dFInrvxf:g:i:m:p:q:s:t:w:z:")) != EOF)
 		switch (op) {
@@ -397,6 +506,10 @@
 			break;
 
 		case 'g':
+			if (strlen(optarg) >= MAXHOSTNAMELEN) {
+			    Fprintf(stderr, "%s: Gateway address too long\n", prog);
+			    exit(-1);
+			}
 			if (lsrr >= NGATEWAYS) {
 				Fprintf(stderr,
 				    "%s: No more than %d gateways\n",
@@ -409,6 +522,11 @@
 
 		case 'i':
 			device = optarg;
+			if (strlen(device) >= 16) { /* that is the IFNAMSIZ
+						     * from kernel headers */
+			    Fprintf(stderr, "%s: Interface name too long\n", prog);
+			    exit(-1);
+			}
 			break;
 
 		case 'I':
@@ -442,10 +560,15 @@
 			 * probe (e.g., on a multi-homed host).
 			 */
 			source = optarg;
+			if (strlen(source) >= MAXHOSTNAMELEN) {
+			    Fprintf(stderr, "%s: Source address too long\n", prog);
+			    exit(-1);
+			}
 			break;
 
 		case 't':
 			tos = str2val(optarg, "tos", 0, 255);
+			previous_tos = tos;
 			++settos;
 			break;
 
@@ -500,6 +623,10 @@
 
 	case 1:
 		hostname = argv[optind];
+		if (strlen(hostname) >= MAXHOSTNAMELEN) {
+		    Fprintf(stderr, "%s: Address too long\n", prog);
+		    exit(-1);
+		}
 		hi = gethostinfo(hostname);
 		setsin(to, hi->addrs[0]);
 		if (hi->n > 1)
@@ -515,6 +642,16 @@
 		usage();
 	}
 
+	/* This checking was moved here by oh3mqu+rpm@vip.fi */
+	/* It was useless before packlen gets command line value */
+	if (packlen == 0)
+		packlen = minpacket;		/* minimum sized packet */
+	else if (minpacket > packlen || packlen > maxpacket) {
+		Fprintf(stderr, "%s: packet size must be %d <= s <= %d\n",
+		    prog, minpacket, maxpacket);
+		exit(1);
+	}
+
 #ifdef HAVE_SETLINEBUF
 	setlinebuf (stdout);
 #else
@@ -578,46 +715,35 @@
 		outip->ip_p = IPPROTO_UDP;
 
 		outudp = (struct udphdr *)outp;
+#ifdef LAUGHTER
 		outudp->uh_sport = htons(ident);
-		outudp->uh_ulen =
-		    htons((u_short)(packlen - (sizeof(*outip) + optlen)));
-		outdata = (struct outdata *)(outudp + 1);
-	}
-
-	cp = "icmp";
-	if ((pe = getprotobyname(cp)) == NULL) {
-		Fprintf(stderr, "%s: unknown protocol %s\n", prog, cp);
+#else
+		/* Avoid udp port conflicts! */
+		if (!useicmp) {
+			struct sockaddr_in s;
+			int alen = sizeof(s);
+			int lock_fd = socket(AF_INET, SOCK_DGRAM, 0);
+			if (lock_fd < 0) {
+				perror("socket");
 		exit(1);
 	}
-
-	/* Insure the socket fds won't be 0, 1 or 2 */
-	if (open(devnull, O_RDONLY) < 0 ||
-	    open(devnull, O_RDONLY) < 0 ||
-	    open(devnull, O_RDONLY) < 0) {
-		Fprintf(stderr, "%s: open \"%s\": %s\n",
-		    prog, devnull, strerror(errno));
+			memset(&s, 0, sizeof(s));
+			if (bind(lock_fd, (struct sockaddr*)&s, sizeof(s)) == -1) {
+				perror("bind");
 		exit(1);
 	}
-	if ((s = socket(AF_INET, SOCK_RAW, pe->p_proto)) < 0) {
-		Fprintf(stderr, "%s: icmp socket: %s\n", prog, strerror(errno));
+			if (getsockname(lock_fd, (struct sockaddr*)&s, &alen) == -1) {
+				perror("getsockname");
 		exit(1);
 	}
-	if (options & SO_DEBUG)
-		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, (char *)&on,
-		    sizeof(on));
-	if (options & SO_DONTROUTE)
-		(void)setsockopt(s, SOL_SOCKET, SO_DONTROUTE, (char *)&on,
-		    sizeof(on));
-
-#ifndef __hpux
-	sndsock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
-#else
-	sndsock = socket(AF_INET, SOCK_RAW,
-	    useicmp ? IPPROTO_ICMP : IPPROTO_UDP);
+			uh_sport = s.sin_port;
+			outudp->uh_sport = s.sin_port;
+			/* DO NOT CLOSE LOCK SOCKET */
+		}
 #endif
-	if (sndsock < 0) {
-		Fprintf(stderr, "%s: raw socket: %s\n", prog, strerror(errno));
-		exit(1);
+		outudp->uh_ulen =
+		    htons((u_short)(packlen - (sizeof(*outip) + optlen)));
+		outdata = (struct outdata *)(outudp + 1);
 	}
 
 #if defined(IP_OPTIONS) && !defined(HAVE_RAW_OPTIONS)
@@ -653,6 +779,11 @@
 	}
 #endif
 
+	if (options & SO_DEBUG)
+		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, (char *)&on, sizeof(on));
+	if (options & SO_DONTROUTE) 
+		(void)setsockopt(s, SOL_SOCKET, SO_DONTROUTE, (char *)&on, sizeof(on));
+
 #ifdef SO_SNDBUF
 	if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, (char *)&packlen,
 	    sizeof(packlen)) < 0) {
@@ -683,8 +814,65 @@
 		(void)setsockopt(sndsock, SOL_SOCKET, SO_DONTROUTE, (char *)&on,
 		    sizeof(on));
 
+        if ( device ) {
+           int rc = setsockopt(sndsock, SOL_SOCKET, SO_BINDTODEVICE, device, strlen(device) + 1);
+
+           if ( rc ) {
+             perror("setsockopt");
+             fprintf(stderr, "unable to bind to device: %s\n", device);
+             exit(1);
+           }
+         }
+                
+#ifndef LAUGHTER
+	do {
+		int alen;
+		int probe_fd = socket(AF_INET, SOCK_DGRAM, 0);
+		int sport;
+
+		if (probe_fd < 0) {
+			perror("socket");
+			exit(1);
+		}
+		if (device) {
+			struct ifreq ifr;
+			strncpy(ifr.ifr_name, device, IFNAMSIZ-1);
+			if (setsockopt(probe_fd, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr)) == -1) {
+				close(probe_fd);
+				break;
+			}
+		}
+		sport = to->sin_port;
+		to->sin_port = htons(1025);
+		if (connect(probe_fd, (struct sockaddr*)to, sizeof(*to)) == -1) {
+			perror("socket");
+			exit(1);
+		}
+		to->sin_port = sport;
+		alen = sizeof(*from);
+		if (getsockname(probe_fd, (struct sockaddr*)from, &alen) == -1) {
+			perror("getsockname");
+			exit(1);
+		}
+		close(probe_fd);
+		if (source == NULL)
+			goto selected;
+		hi = gethostinfo(source);
+		source = hi->name;
+		hi->name = NULL;
+		for (i = hi->n, ap = hi->addrs; i > 0; --i, ++ap) {
+			if (from->sin_addr.s_addr == *ap) {
+				freehostinfo(hi);
+				goto selected;
+			}
+		}
+		freehostinfo(hi);
+	} while (0);
+#endif
+
 	/* Get the interface address list */
-	n = ifaddrlist(&al, errbuf);
+	n = ifaddrlist(&allist, errbuf);
+	al = allist;
 	if (n < 0) {
 		Fprintf(stderr, "%s: ifaddrlist: %s\n", prog, errbuf);
 		exit(1);
@@ -695,20 +883,40 @@
 		exit(1);
 	}
 
-	/* Look for a specific device */
+	/* bind to a specific device */
 	if (device != NULL) {
+		int rc;
+
+		/* find the source interface */
 		for (i = n; i > 0; --i, ++al)
 			if (strcmp(device, al->device) == 0)
 				break;
+
 		if (i <= 0) {
 			Fprintf(stderr, "%s: Can't find interface %.32s\n",
 			    prog, device);
 			exit(1);
 		}
+
+		/* bind send socket to the target interface */ 
+		rc = setsockopt(sndsock, SOL_SOCKET, SO_BINDTODEVICE, device, strlen(device) + 1);
+		if ( rc ) {
+			fprintf(stderr, "%s: unable to bind to interface %s\n", prog, device);
+			exit(2);
+		}
 	}
 
 	/* Determine our source address */
 	if (source == NULL) {
+#ifdef USE_KERNEL_ROUTING_TABLE
+		/* Search the kernel routing table for a match with the
+		 * destination address.  Then use that interface.  If
+		 * there is no match, default to using the first 
+		 * interface found.
+		 */
+		al = search_routing_table(to, allist, n);
+		setsin(from, al->addr);
+#else
 		/*
 		 * If a device was specified, use the interface address.
 		 * Otherwise, try to determine our source address.
@@ -720,6 +928,7 @@
 			    prog, err);
 			exit(1);
 		}
+#endif
 	} else {
 		hi = gethostinfo(source);
 		source = hi->name;
@@ -755,6 +964,10 @@
 	setgid(getgid());
 	setuid(getuid());
 
+
+#ifndef LAUGHTER
+selected:
+#endif
 	outip->ip_src = from->sin_addr;
 #ifndef IP_HDRINCL
 	if (bind(sndsock, (struct sockaddr *)from, sizeof(*from)) < 0) {
@@ -764,6 +977,27 @@
 	}
 #endif
 
+#ifdef linux
+	if (bind(sndsock, (struct sockaddr *)from, sizeof(*from)) < 0) {
+		Fprintf(stderr, "%s: bind: %s\n",
+		    prog, strerror(errno));
+		exit (1);
+	}
+	if (bind(s, (struct sockaddr *)from, sizeof(*from)) < 0) {
+		Fprintf(stderr, "%s: bind ICMP socket: %s\n",
+			prog, strerror(errno));
+		exit (1);
+	}
+	if (1) {
+		struct icmp_filter filt;
+		filt.data = ~((1<<ICMP_TIMXCEED)|(1<<ICMP_UNREACH));
+		if (useicmp)
+			filt.data &= ~(1<<ICMP_ECHOREPLY);
+		if (setsockopt(s, SOL_RAW, ICMP_FILTER, (char*)&filt, sizeof(filt)) == -1)
+			perror("WARNING: setsockopt(ICMP_FILTER)");
+	}
+#endif
+
 	Fprintf(stderr, "%s to %s (%s)",
 	    prog, hostname, inet_ntoa(to->sin_addr));
 	if (source)
@@ -803,6 +1037,19 @@
 					++gotlastaddr;
 				}
 				Printf("  %.3f ms", deltaT(&t1, &t2));
+
+				/* Only check if we set a TOS or it hasn't been zeroed/changed yet */
+				if (settos && previous_tos) {
+					/* We have to dig out TOS from the ICMP-encapsulated IP header */
+					struct ip *ip = (struct ip *)packet;
+					struct icmp *icp = (struct icmp *)(((u_char *)ip)+(ip->ip_hl<<2));
+					struct ip *inner_ip = (struct ip *) (((u_char *)icp)+ICMP_MINLEN);
+					if (inner_ip->ip_tos != previous_tos) {
+						Printf(" (TOS=%d!)", inner_ip->ip_tos);
+						previous_tos = inner_ip->ip_tos;
+					}
+				}
+
 				if (i == -2) {
 #ifndef ARCHAIC
 					ip = (struct ip *)packet;
@@ -876,6 +1123,8 @@
 			}
 			if (cc == 0)
 				Printf(" *");
+			if (cc && probe == nprobes-1)
+			    decode_extensions(packet, cc);
 			(void)fflush(stdout);
 		}
 		putchar('\n');
@@ -886,6 +1135,118 @@
 	exit(0);
 }
 
+void
+decode_extensions(u_char *buf, int ip_len)
+{
+	struct icmp_ext_cmn_hdr *cmn_hdr;
+	struct icmp_ext_obj_hdr *obj_hdr;
+	struct mpls_header *mpls;
+	int datalen, obj_len;
+	u_int32_t mpls_h;
+	struct ip *ip;
+
+	ip = (struct ip *)buf;
+
+	if (ip_len <= sizeof(struct ip) + ICMP_EXT_OFFSET) {
+	    /*
+	     * No support for ICMP extensions on this host
+	     */
+	    return;
+	}
+
+	/*
+	 * Move forward to the start of the ICMP extensions, if present
+	 */
+	buf += (ip->ip_hl << 2) + ICMP_EXT_OFFSET;
+	cmn_hdr = (struct icmp_ext_cmn_hdr *)buf;
+
+	if (cmn_hdr->version != ICMP_EXT_VERSION) {
+	    /*
+	     * Unknown version
+	     */
+	    return;
+	}
+
+	datalen = ip_len - ((u_char *)cmn_hdr - (u_char *)ip);
+
+	/*
+	 * Check the checksum, cmn_hdr->checksum == 0 means no checksum'ing
+	 * done by sender.
+	 *
+	 * If the checksum is ok, we'll get 0, as the checksum is calculated
+	 * with	the checksum field being 0'd.
+	 */
+	if (ntohs(cmn_hdr->checksum) &&
+	    in_cksum((u_short *)cmn_hdr, datalen)) {
+
+	    return;
+	}
+
+	buf += sizeof(*cmn_hdr);
+	datalen -= sizeof(*cmn_hdr);
+
+	while (datalen > 0) {
+	    obj_hdr = (struct icmp_ext_obj_hdr *)buf;
+	    obj_len = ntohs(obj_hdr->length);
+
+	    /*
+	     * Sanity check the length field
+	     */
+	    if (obj_len > datalen) {
+		return;
+	    }
+
+	    datalen -= obj_len;
+
+	    /*
+	     * Move past the object header
+	     */
+	    buf += sizeof(struct icmp_ext_obj_hdr);
+	    obj_len -= sizeof(struct icmp_ext_obj_hdr);
+
+	    switch (obj_hdr->class_num) {
+	    case MPLS_STACK_ENTRY_CLASS:
+		switch (obj_hdr->c_type) {
+		case MPLS_STACK_ENTRY_C_TYPE:
+		    while (obj_len >= sizeof(u_int32_t)) {
+			mpls_h = ntohl(*(u_int32_t *)buf);
+
+			buf += sizeof(u_int32_t);
+			obj_len -= sizeof(u_int32_t);
+
+			mpls = (struct mpls_header *) &mpls_h;
+			printf("\n     MPLS Label=%d CoS=%d TTL=%d S=%d",
+			       mpls->label, mpls->exp, mpls->ttl, mpls->s);
+		    }
+		    if (obj_len > 0) {
+			/*
+			 * Something went wrong, and we're at a unknown offset
+			 * into the packet, ditch the rest of it.
+			 */
+			return;
+		    }
+		    break;
+		default:
+		    /*
+		     * Unknown object, skip past it
+		     */
+		    buf += ntohs(obj_hdr->length) -
+			sizeof(struct icmp_ext_obj_hdr);
+		    break;
+		}
+		break;
+
+	    default:
+		/*
+		 * Unknown object, skip past it
+		 */
+		buf += ntohs(obj_hdr->length) -
+		    sizeof(struct icmp_ext_obj_hdr);
+		break;
+	    }
+	}
+}
+
 int
 wait_for_reply(register int sock, register struct sockaddr_in *fromp,
     register const struct timeval *tp)
@@ -919,10 +1280,21 @@
 	struct ip tip;
 
 	outip->ip_ttl = ttl;
+#ifdef linux
+	/* Do not fiddle with ID, it must be unique
+	   and only kernel is allowed to make it. --ANK
+	*/
+	outip->ip_id = 0;
+#else
 #ifndef __hpux
 	outip->ip_id = htons(ident + seq);
 #endif
+#endif
 
+#ifdef LAUGHTER
+	/* The comment below has nothing to do with reality and
+	   udp cksum has nothing to do with ip one. --ANK
+	 */
 	/*
 	 * In most cases, the kernel will recalculate the ip checksum.
 	 * But we must do it anyway so that the udp checksum comes out
@@ -934,11 +1306,12 @@
 		if (outip->ip_sum == 0)
 			outip->ip_sum = 0xffff;
 	}
+#endif
 
 	/* Payload */
 	outdata->seq = seq;
 	outdata->ttl = ttl;
-	outdata->tv = *tp;
+	memcpy(&outdata->tv, tp, sizeof(outdata->tv));
 
 	if (useicmp)
 		outicmp->icmp_seq = htons(seq);
@@ -953,6 +1326,7 @@
 		if (outicmp->icmp_cksum == 0)
 			outicmp->icmp_cksum = 0xffff;
 	} else if (doipcksum) {
+#ifdef FULL_CRAP_I_WONDER_WHY_LBNL_FOLKS_DID_IT
 		/* Checksum (we must save and restore ip header) */
 		tip = *outip;
 		ui = (struct udpiphdr *)outip;
@@ -968,6 +1342,30 @@
 		if (outudp->uh_sum == 0)
 			outudp->uh_sum = 0xffff;
 		*outip = tip;
+#else
+		struct udpmagichdr {
+			struct in_addr src;
+			struct in_addr dst;
+			u_char zero;
+			u_char proto;
+			u_short len;
+		} h, saved, *hptr;
+
+		h.src = outip->ip_src;
+		h.dst = to->sin_addr;
+		h.zero = 0;
+		h.proto = IPPROTO_UDP;
+		h.len = outudp->uh_ulen;
+		hptr = ((struct udpmagichdr*)outudp) - 1;
+		saved = *hptr;
+		*hptr = h;
+		outudp->uh_sum = 0;
+		outudp->uh_sum = in_cksum((u_short *)hptr, ntohs(outudp->uh_ulen) + sizeof(*hptr));
+		if (outudp->uh_sum == 0)
+			outudp->uh_sum = 0xffff;
+		*hptr = saved;
+#endif
+
 	}
 
 	/* XXX undocumented debugging hack */
@@ -1073,6 +1471,10 @@
 #else
 	icp = (struct icmp *)buf;
 #endif
+
+	if (in_cksum((u_short *)icp, htons(ip->ip_len) - hlen))
+		fprintf(stderr, "Icmp checksum is wrong\n");
+
 	type = icp->icmp_type;
 	code = icp->icmp_code;
 	/* Path MTU Discovery (RFC1191) */
@@ -1112,7 +1514,11 @@
 			/* XXX 8 is a magic number */
 			if (hlen + 12 <= cc &&
 			    hip->ip_p == IPPROTO_UDP &&
+#ifdef LAUGHTER
 			    up->uh_sport == htons(ident) &&
+#else
+			    up->uh_sport == uh_sport &&
+#endif
 			    up->uh_dport == htons(port + seq))
 				return (type == ICMP_TIMXCEED ? -1 : code + 1);
 		}
@@ -1155,6 +1561,8 @@
 
 /*
  * Checksum routine for Internet Protocol family headers (C Version)
+ *
+ * Certainly, it was broken --ANK
  */
 u_short
 in_cksum(register u_short *addr, register int len)
@@ -1177,7 +1585,7 @@
 
 	/* mop up an odd byte, if necessary */
 	if (nleft == 1)
-		sum += *(u_char *)w;
+		sum += htons(*(u_char *)w<<8);
 
 	/*
 	 * add back carry outs from top 16 bits to low 16 bits
@@ -1386,3 +1794,103 @@
 	    "\t[-w waittime] [-z pausemsecs] host [packetlen]\n", prog);
 	exit(1);
 }
+
+
+#ifdef USE_KERNEL_ROUTING_TABLE
+
+/* This function currently only supports IPv4.  Someone who knows
+ * more about multi-protocol socket stuff should take a look at this.
+ * 
+ * (But does it make any sense for traceroute to support other 
+ * protocols?  Maybe IPv6...
+ */
+
+struct ifaddrlist *search_routing_table(struct sockaddr_in *to, struct ifaddrlist *al, int n)
+{
+	struct ifaddrlist *first_if;
+	FILE *fp;
+	char buf[1024];
+	char ifname[128];
+        unsigned int route_dest;
+	unsigned int mask;
+	unsigned int best_mask;
+	unsigned int dest_addr;
+	unsigned int best_addr;
+	unsigned int gateway;
+	unsigned int use_gateway;
+	unsigned int convs;
+
+	/* How come using ntohl(to->sin_addr.s_addr) doesn't work here? */
+	dest_addr = to->sin_addr.s_addr;
+
+	fp = fopen("/proc/net/route", "r");
+	if (fp == NULL) {
+		return al;
+	}
+
+	/* Skip the first line (the column headings) */
+	if (fgets(buf, sizeof(buf), fp) == NULL) {
+		fclose(fp);
+		return al;
+	}
+
+	best_mask = 0;
+	best_addr = 0;
+	use_gateway = 0;
+	
+	while (fgets(buf, sizeof(buf), fp) != NULL) {
+		/* Field 1: interface name
+		 * Field 2: dest addr
+		 * Field 3: gateway addr
+		 * Field 8: genmask 
+		 */
+ 		convs = sscanf(buf, "%s %x %x %*s %*s %*s %*s %x", 
+ 				ifname, &route_dest, &gateway, &mask);
+ 		if (convs != 4) {
+			/* format error .... */
+			fclose(fp);
+			return al;
+		}
+
+		if ((dest_addr & mask) == route_dest) {
+			/* This routing entry applies to
+			 * our destination addr
+			 */
+			if ((mask > best_mask) || (best_mask == 0)) {
+				/* And it is more specific than any
+				 * previous match (or is the first match)
+				 */
+				best_mask = mask;
+				best_addr = route_dest;
+				use_gateway = gateway;
+			}
+		}
+	}
+
+	fclose(fp);
+
+	/* If we don't find a match, we'll return the first entry */
+	first_if = al;
+
+	while (al < first_if + n) {
+		/* Use different approach if we send through gateway */
+		if (use_gateway) {
+			if ((al->addr & al->mask) == (use_gateway & al->mask)) {
+				return al;
+			}
+		} else {
+		/* Better way than comparing if names,
+		   this works with aliased if:s too */
+		if (best_addr == (al->addr & al->mask)) {
+			/* Got a match */
+			return al;
+		}
+		}
+		al++;
+	}
+
+	return first_if;
+}
+			
+#endif
+
diff -Nurb traceroute-1.4a12.old/traceroute.c.orig traceroute-1.4a12/traceroute.c.orig
--- traceroute-1.4a12.old/traceroute.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ traceroute-1.4a12/traceroute.c.orig	2004-08-16 13:11:06.000000000 +0100
@@ -0,0 +1,1732 @@
+/*
+ * Copyright (c) 1988, 1989, 1991, 1994, 1995, 1996, 1997, 1998, 1999, 2000
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code distributions
+ * retain the above copyright notice and this paragraph in its entirety, (2)
+ * distributions including binary code include the above copyright notice and
+ * this paragraph in its entirety in the documentation or other materials
+ * provided with the distribution, and (3) all advertising materials mentioning
+ * features or use of this software display the following acknowledgement:
+ * ``This product includes software developed by the University of California,
+ * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+ * the University nor the names of its contributors may be used to endorse
+ * or promote products derived from this software without specific prior
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef lint
+static const char copyright[] =
+    "@(#) Copyright (c) 1988, 1989, 1991, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n\
+The Regents of the University of California.  All rights reserved.\n";
+static const char rcsid[] =
+    "@(#)$Id: traceroute-1.4a12-fc2.patch,v 1.1 2004/08/16 12:48:24 lawrence Exp $ (LBL)";
+#endif
+
+/*
+ * traceroute host  - trace the route ip packets follow going to "host".
+ *
+ * Attempt to trace the route an ip packet would follow to some
+ * internet host.  We find out intermediate hops by launching probe
+ * packets with a small ttl (time to live) then listening for an
+ * icmp "time exceeded" reply from a gateway.  We start our probes
+ * with a ttl of one and increase by one until we get an icmp "port
+ * unreachable" (which means we got to "host") or hit a max (which
+ * defaults to 30 hops & can be changed with the -m flag).  Three
+ * probes (change with -q flag) are sent at each ttl setting and a
+ * line is printed showing the ttl, address of the gateway and
+ * round trip time of each probe.  If the probe answers come from
+ * different gateways, the address of each responding system will
+ * be printed.  If there is no response within a 5 sec. timeout
+ * interval (changed with the -w flag), a "*" is printed for that
+ * probe.
+ *
+ * Probe packets are UDP format.  We don't want the destination
+ * host to process them so the destination port is set to an
+ * unlikely value (if some clod on the destination is using that
+ * value, it can be changed with the -p flag).
+ *
+ * A sample use might be:
+ *
+ *     [yak 71]% traceroute nis.nsf.net.
+ *     traceroute to nis.nsf.net (35.1.1.48), 30 hops max, 56 byte packet
+ *      1  helios.ee.lbl.gov (128.3.112.1)  19 ms  19 ms  0 ms
+ *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms
+ *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms
+ *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  39 ms
+ *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  39 ms  39 ms  39 ms
+ *      6  128.32.197.4 (128.32.197.4)  40 ms  59 ms  59 ms
+ *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  59 ms
+ *      8  129.140.70.13 (129.140.70.13)  99 ms  99 ms  80 ms
+ *      9  129.140.71.6 (129.140.71.6)  139 ms  239 ms  319 ms
+ *     10  129.140.81.7 (129.140.81.7)  220 ms  199 ms  199 ms
+ *     11  nic.merit.edu (35.1.1.48)  239 ms  239 ms  239 ms
+ *
+ * Note that lines 2 & 3 are the same.  This is due to a buggy
+ * kernel on the 2nd hop system -- lbl-csam.arpa -- that forwards
+ * packets with a zero ttl.
+ *
+ * A more interesting example is:
+ *
+ *     [yak 72]% traceroute allspice.lcs.mit.edu.
+ *     traceroute to allspice.lcs.mit.edu (18.26.0.115), 30 hops max
+ *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms
+ *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  19 ms  19 ms
+ *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  19 ms
+ *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  19 ms  39 ms  39 ms
+ *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  20 ms  39 ms  39 ms
+ *      6  128.32.197.4 (128.32.197.4)  59 ms  119 ms  39 ms
+ *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  39 ms
+ *      8  129.140.70.13 (129.140.70.13)  80 ms  79 ms  99 ms
+ *      9  129.140.71.6 (129.140.71.6)  139 ms  139 ms  159 ms
+ *     10  129.140.81.7 (129.140.81.7)  199 ms  180 ms  300 ms
+ *     11  129.140.72.17 (129.140.72.17)  300 ms  239 ms  239 ms
+ *     12  * * *
+ *     13  128.121.54.72 (128.121.54.72)  259 ms  499 ms  279 ms
+ *     14  * * *
+ *     15  * * *
+ *     16  * * *
+ *     17  * * *
+ *     18  ALLSPICE.LCS.MIT.EDU (18.26.0.115)  339 ms  279 ms  279 ms
+ *
+ * (I start to see why I'm having so much trouble with mail to
+ * MIT.)  Note that the gateways 12, 14, 15, 16 & 17 hops away
+ * either don't send ICMP "time exceeded" messages or send them
+ * with a ttl too small to reach us.  14 - 17 are running the
+ * MIT C Gateway code that doesn't send "time exceeded"s.  God
+ * only knows what's going on with 12.
+ *
+ * The silent gateway 12 in the above may be the result of a bug in
+ * the 4.[23]BSD network code (and its derivatives):  4.x (x <= 3)
+ * sends an unreachable message using whatever ttl remains in the
+ * original datagram.  Since, for gateways, the remaining ttl is
+ * zero, the icmp "time exceeded" is guaranteed to not make it back
+ * to us.  The behavior of this bug is slightly more interesting
+ * when it appears on the destination system:
+ *
+ *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms
+ *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  39 ms
+ *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  39 ms  19 ms
+ *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  19 ms
+ *      5  ccn-nerif35.Berkeley.EDU (128.32.168.35)  39 ms  39 ms  39 ms
+ *      6  csgw.Berkeley.EDU (128.32.133.254)  39 ms  59 ms  39 ms
+ *      7  * * *
+ *      8  * * *
+ *      9  * * *
+ *     10  * * *
+ *     11  * * *
+ *     12  * * *
+ *     13  rip.Berkeley.EDU (128.32.131.22)  59 ms !  39 ms !  39 ms !
+ *
+ * Notice that there are 12 "gateways" (13 is the final
+ * destination) and exactly the last half of them are "missing".
+ * What's really happening is that rip (a Sun-3 running Sun OS3.5)
+ * is using the ttl from our arriving datagram as the ttl in its
+ * icmp reply.  So, the reply will time out on the return path
+ * (with no notice sent to anyone since icmp's aren't sent for
+ * icmp's) until we probe with a ttl that's at least twice the path
+ * length.  I.e., rip is really only 7 hops away.  A reply that
+ * returns with a ttl of 1 is a clue this problem exists.
+ * Traceroute prints a "!" after the time if the ttl is <= 1.
+ * Since vendors ship a lot of obsolete (DEC's Ultrix, Sun 3.x) or
+ * non-standard (HPUX) software, expect to see this problem
+ * frequently and/or take care picking the target host of your
+ * probes.
+ *
+ * Other possible annotations after the time are !H, !N, !P (got a host,
+ * network or protocol unreachable, respectively), !S or !F (source
+ * route failed or fragmentation needed -- neither of these should
+ * ever occur and the associated gateway is busted if you see one).  If
+ * almost all the probes result in some kind of unreachable, traceroute
+ * will give up and exit.
+ *
+ * Notes
+ * -----
+ * This program must be run by root or be setuid.  (I suggest that
+ * you *don't* make it setuid -- casual use could result in a lot
+ * of unnecessary traffic on our poor, congested nets.)
+ *
+ * This program requires a kernel mod that does not appear in any
+ * system available from Berkeley:  A raw ip socket using proto
+ * IPPROTO_RAW must interpret the data sent as an ip datagram (as
+ * opposed to data to be wrapped in a ip datagram).  See the README
+ * file that came with the source to this program for a description
+ * of the mods I made to /sys/netinet/raw_ip.c.  Your mileage may
+ * vary.  But, again, ANY 4.x (x < 4) BSD KERNEL WILL HAVE TO BE
+ * MODIFIED TO RUN THIS PROGRAM.
+ *
+ * The udp port usage may appear bizarre (well, ok, it is bizarre).
+ * The problem is that an icmp message only contains 8 bytes of
+ * data from the original datagram.  8 bytes is the size of a udp
+ * header so, if we want to associate replies with the original
+ * datagram, the necessary information must be encoded into the
+ * udp header (the ip id could be used but there's no way to
+ * interlock with the kernel's assignment of ip id's and, anyway,
+ * it would have taken a lot more kernel hacking to allow this
+ * code to set the ip id).  So, to allow two or more users to
+ * use traceroute simultaneously, we use this task's pid as the
+ * source port (the high bit is set to move the port number out
+ * of the "likely" range).  To keep track of which probe is being
+ * replied to (so times and/or hop counts don't get confused by a
+ * reply that was delayed in transit), we increment the destination
+ * port number before each probe.
+ *
+ * Don't use this as a coding example.  I was trying to find a
+ * routing problem and this code sort-of popped out after 48 hours
+ * without sleep.  I was amazed it ever compiled, much less ran.
+ *
+ * I stole the idea for this program from Steve Deering.  Since
+ * the first release, I've learned that had I attended the right
+ * IETF working group meetings, I also could have stolen it from Guy
+ * Almes or Matt Mathis.  I don't know (or care) who came up with
+ * the idea first.  I envy the originators' perspicacity and I'm
+ * glad they didn't keep the idea a secret.
+ *
+ * Tim Seaver, Ken Adelman and C. Philip Wood provided bug fixes and/or
+ * enhancements to the original distribution.
+ *
+ * I've hacked up a round-trip-route version of this that works by
+ * sending a loose-source-routed udp datagram through the destination
+ * back to yourself.  Unfortunately, SO many gateways botch source
+ * routing, the thing is almost worthless.  Maybe one day...
+ *
+ *  -- Van Jacobson (van@ee.lbl.gov)
+ *     Tue Dec 20 03:50:13 PST 1988
+ */
+
+#include <sys/param.h>
+#include <sys/file.h>
+#include <sys/ioctl.h>
+#ifdef HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
+#include <sys/socket.h>
+#include <sys/time.h>
+
+#include <net/if.h>
+#include <netinet/in_systm.h>
+#include <netinet/in.h>
+#include <netinet/ip.h>
+#include <netinet/ip_var.h>
+#include <netinet/ip_icmp.h>
+#include <netinet/udp.h>
+#include <netinet/udp_var.h>
+
+#include <linux/sockios.h>
+
+#include <arpa/inet.h>
+
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#ifdef HAVE_MALLOC_H
+#include <malloc.h>
+#endif
+#include <memory.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#ifdef  __linux__
+#include <linux/types.h>
+#include <linux/icmp.h>
+#endif
+
+#include "gnuc.h"
+#ifdef HAVE_OS_PROTO_H
+#include "os-proto.h"
+#endif
+
+/* rfc1716 */
+#ifndef ICMP_UNREACH_FILTER_PROHIB
+#define ICMP_UNREACH_FILTER_PROHIB	13	/* admin prohibited filter */
+#endif
+#ifndef ICMP_UNREACH_HOST_PRECEDENCE
+#define ICMP_UNREACH_HOST_PRECEDENCE	14	/* host precedence violation */
+#endif
+#ifndef ICMP_UNREACH_PRECEDENCE_CUTOFF
+#define ICMP_UNREACH_PRECEDENCE_CUTOFF	15	/* precedence cutoff */
+#endif
+
+#include "findsaddr.h"
+#include "ifaddrlist.h"
+#include "traceroute.h"
+
+/* Maximum number of gateways (include room for one noop) */
+#define NGATEWAYS ((int)((MAX_IPOPTLEN - IPOPT_MINOFF - 1) / sizeof(u_int32_t)))
+
+#ifndef	MAXHOSTNAMELEN
+#define MAXHOSTNAMELEN	256
+#endif
+
+#define Fprintf (void)fprintf
+#define Printf (void)printf
+
+/* Host name and address list */
+struct hostinfo {
+	char *name;
+	int n;
+	u_int32_t *addrs;
+};
+
+/* Data section of the probe packet */
+struct outdata {
+	u_char seq;		/* sequence number of this packet */
+	u_char ttl;		/* ttl packet left with */
+	struct timeval tv __attribute__((packed)); /* time packet left */
+};
+
+#ifndef HAVE_ICMP_NEXTMTU
+/* Path MTU Discovery (RFC1191) */
+struct my_pmtu {
+	u_short ipm_void;
+	u_short ipm_nextmtu;
+};
+#endif
+
+u_char	packet[512];		/* last inbound (icmp) packet */
+
+struct ip *outip;		/* last output (udp) packet */
+struct udphdr *outudp;		/* last output (udp) packet */
+struct outdata *outdata;	/* last output (udp) packet */
+
+struct icmp *outicmp;		/* last output (icmp) packet */
+
+/* loose source route gateway list (including room for final destination) */
+u_int32_t gwlist[NGATEWAYS + 1];
+
+int s;				/* receive (icmp) socket file descriptor */
+int sndsock;			/* send (udp/icmp) socket file descriptor */
+
+struct sockaddr whereto;	/* Who to try to reach */
+struct sockaddr wherefrom;	/* Who we are */
+int packlen;			/* total length of packet */
+int minpacket;			/* min ip packet size */
+#if !defined(IP_MAXPACKET)
+#define	IP_MAXPACKET	64 * 1024
+#endif
+int maxpacket = IP_MAXPACKET;	/* max ip packet size */
+int pmtu;			/* Path MTU Discovery (RFC1191) */
+u_int pausemsecs;
+
+char *prog;
+char *source;
+char *hostname;
+char *device;
+static const char devnull[] = "/dev/null";
+
+int nprobes = 3;
+int max_ttl = 30;
+int first_ttl = 1;
+u_short ident;
+u_short port = 32768 + 666;	/* start udp dest port # for probe packets */
+
+int options;			/* socket options */
+int verbose;
+int waittime = 5;		/* time to wait for response (in seconds) */
+int nflag;			/* print addresses numerically */
+int useicmp;			/* use icmp echo instead of udp packets */
+#ifdef CANT_HACK_IPCKSUM
+int doipcksum = 0;		/* don't calculate ip checksums by default */
+#else
+int doipcksum = 1;		/* calculate ip checksums by default */
+#endif
+int optlen;			/* length of ip options */
+
+extern int optind;
+extern int opterr;
+extern char *optarg;
+
+/* Forwards */
+double	deltaT(struct timeval *, struct timeval *);
+void	freehostinfo(struct hostinfo *);
+void	getaddr(u_int32_t *, char *);
+struct	hostinfo *gethostinfo(char *);
+u_short	in_cksum(u_short *, int);
+char	*inetname(struct in_addr);
+int	main(int, char **);
+int	packet_ok(u_char *, int, struct sockaddr_in *, int);
+char	*pr_type(u_char);
+void	print(u_char *, int, struct sockaddr_in *);
+void	send_probe(int, int, struct timeval *);
+int	str2val(const char *, const char *, int, int);
+void	tvsub(struct timeval *, struct timeval *);
+__dead	void usage(void);
+int	wait_for_reply(int, struct sockaddr_in *, const struct timeval *);
+#ifndef HAVE_USLEEP
+int	usleep(u_int);
+#endif
+
+#ifdef linux
+struct sockaddr_in *to = (struct sockaddr_in *)&whereto;
+#endif
+#ifndef LAUGHTER
+u_short uh_sport;
+#endif
+
+#ifdef USE_KERNEL_ROUTING_TABLE
+struct ifaddrlist *search_routing_table(struct sockaddr_in *to, struct ifaddrlist *al, int n);
+#endif
+
+
+int
+main(int argc, char **argv)
+{
+	register int op, code, n;
+	register char *cp;
+	register const char *err;
+	register u_char *outp;
+	register u_int32_t *ap;
+	register struct sockaddr_in *from = (struct sockaddr_in *)&wherefrom;
+#ifndef	linux
+	register struct sockaddr_in *to = (struct sockaddr_in *)&whereto;
+#endif
+	register struct hostinfo *hi;
+	register struct protoent *pe;
+	int on = 1;
+	register int ttl, probe, i;
+	register int seq = 0;
+	unsigned int tos = 0, previous_tos = 0, settos = 0;
+	register int lsrr = 0;
+	register u_short off = 0;
+	struct ifaddrlist *al, *allist;
+	char errbuf[132];
+
+	if (argv[0] == NULL)
+		prog = "traceroute";
+	else if ((cp = strrchr(argv[0], '/')) != NULL)
+		prog = cp + 1;
+	else
+		prog = argv[0];
+
+	cp = "icmp";
+	if ((pe = getprotobyname(cp)) == NULL) {
+		Fprintf(stderr, "%s: unknown protocol %s\n", prog, cp);
+		exit(1);
+	}
+
+	/* Insure the socket fds won't be 0, 1 or 2 */
+	if (open(devnull, O_RDONLY) < 0 ||
+	    open(devnull, O_RDONLY) < 0 ||
+	    open(devnull, O_RDONLY) < 0) {
+		Fprintf(stderr, "%s: open \"%s\": %s\n",
+		    prog, devnull, strerror(errno));
+		exit(1);
+	}
+	if ((s = socket(AF_INET, SOCK_RAW, pe->p_proto)) < 0) {
+		Fprintf(stderr, "%s: icmp socket: %s\n", prog, strerror(errno));
+		exit(1);
+	}
+
+#ifndef __hpux
+	sndsock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+#else
+	sndsock = socket(AF_INET, SOCK_RAW,
+	useicmp ? IPPROTO_ICMP : IPPROTO_UDP);
+#endif
+
+	if (sndsock < 0) {
+		Fprintf(stderr, "%s: raw socket: %s\n", prog, strerror(errno));
+		exit(1);
+	}
+
+	/* Revert to non-privileged user after opening sockets */
+	setuid(getuid());
+
+	opterr = 0;
+	while ((op = getopt(argc, argv, "dFInrvxf:g:i:m:p:q:s:t:w:z:")) != EOF)
+		switch (op) {
+
+		case 'd':
+			options |= SO_DEBUG;
+			break;
+
+		case 'f':
+			first_ttl = str2val(optarg, "first ttl", 1, 255);
+			break;
+
+		case 'F':
+			off = IP_DF;
+			break;
+
+		case 'g':
+			if (strlen(optarg) >= MAXHOSTNAMELEN) {
+			    Fprintf(stderr, "%s: Gateway address too long\n", prog);
+			    exit(-1);
+			}
+			if (lsrr >= NGATEWAYS) {
+				Fprintf(stderr,
+				    "%s: No more than %d gateways\n",
+				    prog, NGATEWAYS);
+				exit(1);
+			}
+			getaddr(gwlist + lsrr, optarg);
+			++lsrr;
+			break;
+
+		case 'i':
+			device = optarg;
+			if (strlen(device) >= 16) { /* that is the IFNAMSIZ
+						     * from kernel headers */
+			    Fprintf(stderr, "%s: Interface name too long\n", prog);
+			    exit(-1);
+			}
+			break;
+
+		case 'I':
+			++useicmp;
+			break;
+
+		case 'm':
+			max_ttl = str2val(optarg, "max ttl", 1, 255);
+			break;
+
+		case 'n':
+			++nflag;
+			break;
+
+		case 'p':
+			port = (u_short)str2val(optarg, "port",
+			    1, (1 << 16) - 1);
+			break;
+
+		case 'q':
+			nprobes = str2val(optarg, "nprobes", 1, -1);
+			break;
+
+		case 'r':
+			options |= SO_DONTROUTE;
+			break;
+
+		case 's':
+			/*
+			 * set the ip source address of the outbound
+			 * probe (e.g., on a multi-homed host).
+			 */
+			source = optarg;
+			if (strlen(source) >= MAXHOSTNAMELEN) {
+			    Fprintf(stderr, "%s: Source address too long\n", prog);
+			    exit(-1);
+			}
+			break;
+
+		case 't':
+			tos = str2val(optarg, "tos", 0, 255);
+			previous_tos = tos;
+			++settos;
+			break;
+
+		case 'v':
+			++verbose;
+			break;
+
+		case 'x':
+			doipcksum = (doipcksum == 0);
+			break;
+
+		case 'w':
+			waittime = str2val(optarg, "wait time",
+			    2, 24 * 60 * 60);
+			break;
+
+		case 'z':
+			pausemsecs = str2val(optarg, "pause msecs",
+			    0, 60 * 60 * 1000);
+			break;
+
+		default:
+			usage();
+		}
+
+	if (first_ttl > max_ttl) {
+		Fprintf(stderr,
+		    "%s: first ttl (%d) may not be greater than max ttl (%d)\n",
+		    prog, first_ttl, max_ttl);
+		exit(1);
+	}
+
+	if (!doipcksum)
+		Fprintf(stderr, "%s: Warning: ip checksums disabled\n", prog);
+
+	if (lsrr > 0)
+		optlen = (lsrr + 1) * sizeof(gwlist[0]);
+	minpacket = sizeof(*outip) + sizeof(*outdata) + optlen;
+	if (useicmp)
+		minpacket += 8;			/* XXX magic number */
+	else
+		minpacket += sizeof(*outudp);
+	packlen = minpacket;			/* minimum sized packet */
+
+	/* Process destination and optional packet size */
+	switch (argc - optind) {
+
+	case 2:
+		packlen = str2val(argv[optind + 1],
+		    "packet length", minpacket, maxpacket);
+		/* Fall through */
+
+	case 1:
+		hostname = argv[optind];
+		if (strlen(hostname) >= MAXHOSTNAMELEN) {
+		    Fprintf(stderr, "%s: Address too long\n", prog);
+		    exit(-1);
+		}
+		hi = gethostinfo(hostname);
+		setsin(to, hi->addrs[0]);
+		if (hi->n > 1)
+			Fprintf(stderr,
+		    "%s: Warning: %s has multiple addresses; using %s\n",
+				prog, hostname, inet_ntoa(to->sin_addr));
+		hostname = hi->name;
+		hi->name = NULL;
+		freehostinfo(hi);
+		break;
+
+	default:
+		usage();
+	}
+
+	/* This checking was moved here by oh3mqu+rpm@vip.fi */
+	/* It was useless before packlen gets command line value */
+	if (packlen == 0)
+		packlen = minpacket;		/* minimum sized packet */
+	else if (minpacket > packlen || packlen > maxpacket) {
+		Fprintf(stderr, "%s: packet size must be %d <= s <= %d\n",
+		    prog, minpacket, maxpacket);
+		exit(1);
+	}
+
+#ifdef HAVE_SETLINEBUF
+	setlinebuf (stdout);
+#else
+	setvbuf(stdout, NULL, _IOLBF, 0);
+#endif
+
+	outip = (struct ip *)malloc((unsigned)packlen);
+	if (outip == NULL) {
+		Fprintf(stderr, "%s: malloc: %s\n", prog, strerror(errno));
+		exit(1);
+	}
+	memset((char *)outip, 0, packlen);
+
+	outip->ip_v = IPVERSION;
+	if (settos)
+		outip->ip_tos = tos;
+#ifdef BYTESWAP_IP_HDR
+	outip->ip_len = htons(packlen);
+	outip->ip_off = htons(off);
+#else
+	outip->ip_len = packlen;
+	outip->ip_off = off;
+#endif
+	outp = (u_char *)(outip + 1);
+#ifdef HAVE_RAW_OPTIONS
+	if (lsrr > 0) {
+		register u_char *optlist;
+
+		optlist = outp;
+		outp += optlen;
+
+		/* final hop */
+		gwlist[lsrr] = to->sin_addr.s_addr;
+
+		outip->ip_dst.s_addr = gwlist[0];
+
+		/* force 4 byte alignment */
+		optlist[0] = IPOPT_NOP;
+		/* loose source route option */
+		optlist[1] = IPOPT_LSRR;
+		i = lsrr * sizeof(gwlist[0]);
+		optlist[2] = i + 3;
+		/* Pointer to LSRR addresses */
+		optlist[3] = IPOPT_MINOFF;
+		memcpy(optlist + 4, gwlist + 1, i);
+	} else
+#endif
+		outip->ip_dst = to->sin_addr;
+
+	outip->ip_hl = (outp - (u_char *)outip) >> 2;
+	ident = (getpid() & 0xffff) | 0x8000;
+	if (useicmp) {
+		outip->ip_p = IPPROTO_ICMP;
+
+		outicmp = (struct icmp *)outp;
+		outicmp->icmp_type = ICMP_ECHO;
+		outicmp->icmp_id = htons(ident);
+
+		outdata = (struct outdata *)(outp + 8);	/* XXX magic number */
+	} else {
+		outip->ip_p = IPPROTO_UDP;
+
+		outudp = (struct udphdr *)outp;
+#ifdef LAUGHTER
+ 		outudp->uh_sport = htons(ident);
+#else
+		/* Avoid udp port conflicts! */
+		if (!useicmp) {
+			struct sockaddr_in s;
+			int alen = sizeof(s);
+			int lock_fd = socket(AF_INET, SOCK_DGRAM, 0);
+			if (lock_fd < 0) {
+				perror("socket");
+				exit(1);
+			}
+			memset(&s, 0, sizeof(s));
+			if (bind(lock_fd, (struct sockaddr*)&s, sizeof(s)) == -1) {
+				perror("bind");
+				exit(1);
+			}
+			if (getsockname(lock_fd, (struct sockaddr*)&s, &alen) == -1) {
+				perror("getsockname");
+				exit(1);
+			}
+			uh_sport = s.sin_port;
+			outudp->uh_sport = s.sin_port;
+			/* DO NOT CLOSE LOCK SOCKET */
+		}
+#endif
+		outudp->uh_ulen =
+		    htons((u_short)(packlen - (sizeof(*outip) + optlen)));
+		outdata = (struct outdata *)(outudp + 1);
+	}
+
+#if defined(IP_OPTIONS) && !defined(HAVE_RAW_OPTIONS)
+	if (lsrr > 0) {
+		u_char optlist[MAX_IPOPTLEN];
+
+		cp = "ip";
+		if ((pe = getprotobyname(cp)) == NULL) {
+			Fprintf(stderr, "%s: unknown protocol %s\n", prog, cp);
+			exit(1);
+		}
+
+		/* final hop */
+		gwlist[lsrr] = to->sin_addr.s_addr;
+		++lsrr;
+
+		/* force 4 byte alignment */
+		optlist[0] = IPOPT_NOP;
+		/* loose source route option */
+		optlist[1] = IPOPT_LSRR;
+		i = lsrr * sizeof(gwlist[0]);
+		optlist[2] = i + 3;
+		/* Pointer to LSRR addresses */
+		optlist[3] = IPOPT_MINOFF;
+		memcpy(optlist + 4, gwlist, i);
+
+		if ((setsockopt(sndsock, pe->p_proto, IP_OPTIONS,
+		    (char *)optlist, i + sizeof(gwlist[0]))) < 0) {
+			Fprintf(stderr, "%s: IP_OPTIONS: %s\n",
+			    prog, strerror(errno));
+			exit(1);
+		    }
+	}
+#endif
+        
+	if (options & SO_DEBUG)
+		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, (char *)&on, sizeof(on));
+	if (options & SO_DONTROUTE) 
+		(void)setsockopt(s, SOL_SOCKET, SO_DONTROUTE, (char *)&on, sizeof(on));
+
+#ifdef SO_SNDBUF
+	if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, (char *)&packlen,
+	    sizeof(packlen)) < 0) {
+		Fprintf(stderr, "%s: SO_SNDBUF: %s\n", prog, strerror(errno));
+		exit(1);
+	}
+#endif
+#ifdef IP_HDRINCL
+	if (setsockopt(sndsock, IPPROTO_IP, IP_HDRINCL, (char *)&on,
+	    sizeof(on)) < 0) {
+		Fprintf(stderr, "%s: IP_HDRINCL: %s\n", prog, strerror(errno));
+		exit(1);
+	}
+#else
+#ifdef IP_TOS
+	if (settos && setsockopt(sndsock, IPPROTO_IP, IP_TOS,
+	    (char *)&tos, sizeof(tos)) < 0) {
+		Fprintf(stderr, "%s: setsockopt tos %d: %s\n",
+		    prog, tos, strerror(errno));
+		exit(1);
+	}
+#endif
+#endif
+	if (options & SO_DEBUG)
+		(void)setsockopt(sndsock, SOL_SOCKET, SO_DEBUG, (char *)&on,
+		    sizeof(on));
+	if (options & SO_DONTROUTE)
+		(void)setsockopt(sndsock, SOL_SOCKET, SO_DONTROUTE, (char *)&on,
+		    sizeof(on));
+
+        if ( device ) {
+           int rc = setsockopt(sndsock, SOL_SOCKET, SO_BINDTODEVICE, device, strlen(device) + 1);
+
+           if ( rc ) {
+             perror("setsockopt");
+             fprintf(stderr, "unable to bind to device: %s\n", device);
+             exit(1);
+           }
+         }
+                
+#ifndef LAUGHTER
+	do {
+		int alen;
+		int probe_fd = socket(AF_INET, SOCK_DGRAM, 0);
+		int sport;
+
+		if (probe_fd < 0) {
+			perror("socket");
+			exit(1);
+		}
+		if (device) {
+			struct ifreq ifr;
+			strncpy(ifr.ifr_name, device, IFNAMSIZ-1);
+			if (setsockopt(probe_fd, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr)) == -1) {
+				close(probe_fd);
+				break;
+			}
+		}
+		sport = to->sin_port;
+		to->sin_port = htons(1025);
+		if (connect(probe_fd, (struct sockaddr*)to, sizeof(*to)) == -1) {
+			perror("socket");
+			exit(1);
+		}
+		to->sin_port = sport;
+		alen = sizeof(*from);
+		if (getsockname(probe_fd, (struct sockaddr*)from, &alen) == -1) {
+			perror("getsockname");
+			exit(1);
+		}
+		close(probe_fd);
+		if (source == NULL)
+			goto selected;
+		hi = gethostinfo(source);
+		source = hi->name;
+		hi->name = NULL;
+		for (i = hi->n, ap = hi->addrs; i > 0; --i, ++ap) {
+			if (from->sin_addr.s_addr == *ap) {
+				freehostinfo(hi);
+				goto selected;
+			}
+		}
+		freehostinfo(hi);
+	} while (0);
+#endif
+
+	/* Get the interface address list */
+	n = ifaddrlist(&allist, errbuf);
+	al = allist;
+	if (n < 0) {
+		Fprintf(stderr, "%s: ifaddrlist: %s\n", prog, errbuf);
+		exit(1);
+	}
+	if (n == 0) {
+		Fprintf(stderr,
+		    "%s: Can't find any network interfaces\n", prog);
+		exit(1);
+	}
+
+	/* bind to a specific device */
+	if (device != NULL) {
+		int rc;
+
+		/* find the source interface */
+		for (i = n; i > 0; --i, ++al)
+			if (strcmp(device, al->device) == 0)
+				break;
+
+		if (i <= 0) {
+			Fprintf(stderr, "%s: Can't find interface %.32s\n",
+			    prog, device);
+			exit(1);
+		}
+
+		/* bind send socket to the target interface */ 
+		rc = setsockopt(sndsock, SOL_SOCKET, SO_BINDTODEVICE, device, strlen(device) + 1);
+		if ( rc ) {
+			fprintf(stderr, "%s: unable to bind to interface %s\n", prog, device);
+			exit(2);
+		}
+	}
+
+	/* Determine our source address */
+	if (source == NULL) {
+#ifdef USE_KERNEL_ROUTING_TABLE
+		/* Search the kernel routing table for a match with the
+		 * destination address.  Then use that interface.  If
+		 * there is no match, default to using the first 
+		 * interface found.
+		 */
+		al = search_routing_table(to, allist, n);
+		setsin(from, al->addr);
+#else
+		/*
+		 * If a device was specified, use the interface address.
+		 * Otherwise, try to determine our source address.
+		 */
+		if (device != NULL)
+			setsin(from, al->addr);
+		else if ((err = findsaddr(to, from)) != NULL) {
+			Fprintf(stderr, "%s: findsaddr: %s\n",
+			    prog, err);
+			exit(1);
+		}
+#endif
+	} else {
+		hi = gethostinfo(source);
+		source = hi->name;
+		hi->name = NULL;
+		/*
+		 * If the device was specified make sure it
+		 * corresponds to the source address specified.
+		 * Otherwise, use the first address (and warn if
+		 * there are more than one).
+		 */
+		if (device != NULL) {
+			for (i = hi->n, ap = hi->addrs; i > 0; --i, ++ap)
+				if (*ap == al->addr)
+					break;
+			if (i <= 0) {
+				Fprintf(stderr,
+				    "%s: %s is not on interface %.32s\n",
+				    prog, source, device);
+				exit(1);
+			}
+			setsin(from, *ap);
+		} else {
+			setsin(from, hi->addrs[0]);
+			if (hi->n > 1)
+				Fprintf(stderr,
+			"%s: Warning: %s has multiple addresses; using %s\n",
+				    prog, source, inet_ntoa(from->sin_addr));
+		}
+		freehostinfo(hi);
+	}
+
+	/* Revert to non-privileged user after opening sockets */
+	setgid(getgid());
+	setuid(getuid());
+
+
+#ifndef LAUGHTER
+selected:
+#endif
+	outip->ip_src = from->sin_addr;
+#ifndef IP_HDRINCL
+	if (bind(sndsock, (struct sockaddr *)from, sizeof(*from)) < 0) {
+		Fprintf(stderr, "%s: bind: %s\n",
+		    prog, strerror(errno));
+		exit (1);
+	}
+#endif
+
+#ifdef linux
+	if (bind(sndsock, (struct sockaddr *)from, sizeof(*from)) < 0) {
+		Fprintf(stderr, "%s: bind: %s\n",
+		    prog, strerror(errno));
+		exit (1);
+	}
+	if (bind(s, (struct sockaddr *)from, sizeof(*from)) < 0) {
+		Fprintf(stderr, "%s: bind ICMP socket: %s\n",
+			prog, strerror(errno));
+		exit (1);
+	}
+	if (1) {
+		struct icmp_filter filt;
+		filt.data = ~((1<<ICMP_TIMXCEED)|(1<<ICMP_UNREACH));
+		if (useicmp)
+			filt.data &= ~(1<<ICMP_ECHOREPLY);
+		if (setsockopt(s, SOL_RAW, ICMP_FILTER, (char*)&filt, sizeof(filt)) == -1)
+			perror("WARNING: setsockopt(ICMP_FILTER)");
+	}
+#endif
+
+	Fprintf(stderr, "%s to %s (%s)",
+	    prog, hostname, inet_ntoa(to->sin_addr));
+	if (source)
+		Fprintf(stderr, " from %s", source);
+	Fprintf(stderr, ", %d hops max, %d byte packets\n", max_ttl, packlen);
+	(void)fflush(stderr);
+
+	for (ttl = first_ttl; ttl <= max_ttl; ++ttl) {
+		u_int32_t lastaddr = 0;
+		int gotlastaddr = 0;
+		int got_there = 0;
+		int unreachable = 0;
+		int sentfirst = 0;
+
+		Printf("%2d ", ttl);
+		for (probe = 0; probe < nprobes; ++probe) {
+			register int cc;
+			struct timeval t1, t2;
+			struct timezone tz;
+			register struct ip *ip;
+
+			if (sentfirst && pausemsecs > 0)
+				usleep(pausemsecs * 1000);
+			(void)gettimeofday(&t1, &tz);
+			send_probe(++seq, ttl, &t1);
+			++sentfirst;
+			while ((cc = wait_for_reply(s, from, &t1)) != 0) {
+				(void)gettimeofday(&t2, &tz);
+				i = packet_ok(packet, cc, from, seq);
+				/* Skip short packet */
+				if (i == 0)
+					continue;
+				if (!gotlastaddr ||
+				    from->sin_addr.s_addr != lastaddr) {
+					print(packet, cc, from);
+					lastaddr = from->sin_addr.s_addr;
+					++gotlastaddr;
+				}
+				Printf("  %.3f ms", deltaT(&t1, &t2));
+
+				/* Only check if we set a TOS or it hasn't been zeroed/changed yet */
+				if (settos && previous_tos) {
+					/* We have to dig out TOS from the ICMP-encapsulated IP header */
+					struct ip *ip = (struct ip *)packet;
+					struct icmp *icp = (struct icmp *)(((u_char *)ip)+(ip->ip_hl<<2));
+					struct ip *inner_ip = (struct ip *) (((u_char *)icp)+ICMP_MINLEN);
+					if (inner_ip->ip_tos != previous_tos) {
+						Printf(" (TOS=%d!)", inner_ip->ip_tos);
+						previous_tos = inner_ip->ip_tos;
+					}
+				}
+
+				if (i == -2) {
+#ifndef ARCHAIC
+					ip = (struct ip *)packet;
+					if (ip->ip_ttl <= 1)
+						Printf(" !");
+#endif
+					++got_there;
+					break;
+				}
+				/* time exceeded in transit */
+				if (i == -1)
+					break;
+				code = i - 1;
+				switch (code) {
+
+				case ICMP_UNREACH_PORT:
+#ifndef ARCHAIC
+					ip = (struct ip *)packet;
+					if (ip->ip_ttl <= 1)
+						Printf(" !");
+#endif
+					++got_there;
+					break;
+
+				case ICMP_UNREACH_NET:
+					++unreachable;
+					Printf(" !N");
+					break;
+
+				case ICMP_UNREACH_HOST:
+					++unreachable;
+					Printf(" !H");
+					break;
+
+				case ICMP_UNREACH_PROTOCOL:
+					++got_there;
+					Printf(" !P");
+					break;
+
+				case ICMP_UNREACH_NEEDFRAG:
+					++unreachable;
+					Printf(" !F-%d", pmtu);
+					break;
+
+				case ICMP_UNREACH_SRCFAIL:
+					++unreachable;
+					Printf(" !S");
+					break;
+
+				case ICMP_UNREACH_FILTER_PROHIB:
+					++unreachable;
+					Printf(" !X");
+					break;
+
+				case ICMP_UNREACH_HOST_PRECEDENCE:
+					++unreachable;
+					Printf(" !V");
+					break;
+
+				case ICMP_UNREACH_PRECEDENCE_CUTOFF:
+					++unreachable;
+					Printf(" !C");
+					break;
+
+				default:
+					++unreachable;
+					Printf(" !<%d>", code);
+					break;
+				}
+				break;
+			}
+			if (cc == 0)
+				Printf(" *");
+			(void)fflush(stdout);
+		}
+		putchar('\n');
+		if (got_there ||
+		    (unreachable > 0 && unreachable >= nprobes - 1))
+			break;
+	}
+	exit(0);
+}
+
+int
+wait_for_reply(register int sock, register struct sockaddr_in *fromp,
+    register const struct timeval *tp)
+{
+	fd_set fds;
+	struct timeval now, wait;
+	struct timezone tz;
+	register int cc = 0;
+	int fromlen = sizeof(*fromp);
+
+	FD_ZERO(&fds);
+	FD_SET(sock, &fds);
+
+	wait.tv_sec = tp->tv_sec + waittime;
+	wait.tv_usec = tp->tv_usec;
+	(void)gettimeofday(&now, &tz);
+	tvsub(&wait, &now);
+
+	if (select(sock + 1, &fds, NULL, NULL, &wait) > 0)
+		cc = recvfrom(sock, (char *)packet, sizeof(packet), 0,
+			    (struct sockaddr *)fromp, &fromlen);
+
+	return(cc);
+}
+
+void
+send_probe(register int seq, int ttl, register struct timeval *tp)
+{
+	register int cc;
+	register struct udpiphdr *ui, *oui;
+	struct ip tip;
+
+	outip->ip_ttl = ttl;
+#ifdef linux
+	/* Do not fiddle with ID, it must be unique
+	   and only kernel is allowed to make it. --ANK
+	*/
+	outip->ip_id = 0;
+#else
+#ifndef __hpux
+	outip->ip_id = htons(ident + seq);
+#endif
+#endif
+
+#ifdef LAUGHTER
+	/* The comment below has nothing to do with reality and
+	   udp cksum has nothing to do with ip one. --ANK
+	 */
+	/*
+	 * In most cases, the kernel will recalculate the ip checksum.
+	 * But we must do it anyway so that the udp checksum comes out
+	 * right.
+	 */
+	if (doipcksum) {
+		outip->ip_sum =
+		    in_cksum((u_short *)outip, sizeof(*outip) + optlen);
+		if (outip->ip_sum == 0)
+			outip->ip_sum = 0xffff;
+	}
+#endif
+
+	/* Payload */
+	outdata->seq = seq;
+	outdata->ttl = ttl;
+	memcpy(&outdata->tv, tp, sizeof(outdata->tv));
+
+	if (useicmp)
+		outicmp->icmp_seq = htons(seq);
+	else
+		outudp->uh_dport = htons(port + seq);
+
+	if (useicmp) {
+		/* Always calculate checksum for icmp packets */
+		outicmp->icmp_cksum = 0;
+		outicmp->icmp_cksum = in_cksum((u_short *)outicmp,
+		    packlen - (sizeof(*outip) + optlen));
+		if (outicmp->icmp_cksum == 0)
+			outicmp->icmp_cksum = 0xffff;
+	} else if (doipcksum) {
+#ifdef FULL_CRAP_I_WONDER_WHY_LBNL_FOLKS_DID_IT
+		/* Checksum (we must save and restore ip header) */
+		tip = *outip;
+		ui = (struct udpiphdr *)outip;
+		oui = (struct udpiphdr *)&tip;
+		/* Easier to zero and put back things that are ok */
+		memset((char *)ui, 0, sizeof(ui->ui_i));
+		ui->ui_src = oui->ui_src;
+		ui->ui_dst = oui->ui_dst;
+		ui->ui_pr = oui->ui_pr;
+		ui->ui_len = outudp->uh_ulen;
+		outudp->uh_sum = 0;
+		outudp->uh_sum = in_cksum((u_short *)ui, packlen);
+		if (outudp->uh_sum == 0)
+			outudp->uh_sum = 0xffff;
+		*outip = tip;
+#else
+		struct udpmagichdr {
+			struct in_addr src;
+			struct in_addr dst;
+			u_char zero;
+			u_char proto;
+			u_short len;
+		} h, saved, *hptr;
+
+		h.src = outip->ip_src;
+		h.dst = to->sin_addr;
+		h.zero = 0;
+		h.proto = IPPROTO_UDP;
+		h.len = outudp->uh_ulen;
+		hptr = ((struct udpmagichdr*)outudp) - 1;
+		saved = *hptr;
+		*hptr = h;
+		outudp->uh_sum = 0;
+		outudp->uh_sum = in_cksum((u_short *)hptr, ntohs(outudp->uh_ulen) + sizeof(*hptr));
+		if (outudp->uh_sum == 0)
+			outudp->uh_sum = 0xffff;
+		*hptr = saved;
+#endif
+
+	}
+
+	/* XXX undocumented debugging hack */
+	if (verbose > 1) {
+		register const u_short *sp;
+		register int nshorts, i;
+
+		sp = (u_short *)outip;
+		nshorts = (u_int)packlen / sizeof(u_short);
+		i = 0;
+		Printf("[ %d bytes", packlen);
+		while (--nshorts >= 0) {
+			if ((i++ % 8) == 0)
+				Printf("\n\t");
+			Printf(" %04x", ntohs(*sp++));
+		}
+		if (packlen & 1) {
+			if ((i % 8) == 0)
+				Printf("\n\t");
+			Printf(" %02x", *(u_char *)sp);
+		}
+		Printf("]\n");
+	}
+
+#if !defined(IP_HDRINCL) && defined(IP_TTL)
+	if (setsockopt(sndsock, IPPROTO_IP, IP_TTL,
+	    (char *)&ttl, sizeof(ttl)) < 0) {
+		Fprintf(stderr, "%s: setsockopt ttl %d: %s\n",
+		    prog, ttl, strerror(errno));
+		exit(1);
+	}
+#endif
+
+#ifdef __hpux
+	cc = sendto(sndsock, useicmp ? (char *)outicmp : (char *)outudp,
+	    packlen - (sizeof(*outip) + optlen), 0, &whereto, sizeof(whereto));
+	if (cc > 0)
+		cc += sizeof(*outip) + optlen;
+#else
+	cc = sendto(sndsock, (char *)outip,
+	    packlen, 0, &whereto, sizeof(whereto));
+#endif
+	if (cc < 0 || cc != packlen)  {
+		if (cc < 0)
+			Fprintf(stderr, "%s: sendto: %s\n",
+			    prog, strerror(errno));
+		Printf("%s: wrote %s %d chars, ret=%d\n",
+		    prog, hostname, packlen, cc);
+		(void)fflush(stdout);
+	}
+}
+
+double
+deltaT(struct timeval *t1p, struct timeval *t2p)
+{
+	register double dt;
+
+	dt = (double)(t2p->tv_sec - t1p->tv_sec) * 1000.0 +
+	     (double)(t2p->tv_usec - t1p->tv_usec) / 1000.0;
+	return (dt);
+}
+
+/*
+ * Convert an ICMP "type" field to a printable string.
+ */
+char *
+pr_type(register u_char t)
+{
+	static char *ttab[] = {
+	"Echo Reply",	"ICMP 1",	"ICMP 2",	"Dest Unreachable",
+	"Source Quench", "Redirect",	"ICMP 6",	"ICMP 7",
+	"Echo",		"ICMP 9",	"ICMP 10",	"Time Exceeded",
+	"Param Problem", "Timestamp",	"Timestamp Reply", "Info Request",
+	"Info Reply"
+	};
+
+	if (t > 16)
+		return("OUT-OF-RANGE");
+
+	return(ttab[t]);
+}
+
+int
+packet_ok(register u_char *buf, int cc, register struct sockaddr_in *from,
+    register int seq)
+{
+	register struct icmp *icp;
+	register u_char type, code;
+	register int hlen;
+#ifndef ARCHAIC
+	register struct ip *ip;
+
+	ip = (struct ip *) buf;
+	hlen = ip->ip_hl << 2;
+	if (cc < hlen + ICMP_MINLEN) {
+		if (verbose)
+			Printf("packet too short (%d bytes) from %s\n", cc,
+				inet_ntoa(from->sin_addr));
+		return (0);
+	}
+	cc -= hlen;
+	icp = (struct icmp *)(buf + hlen);
+#else
+	icp = (struct icmp *)buf;
+#endif
+
+	if (in_cksum((u_short *)icp, htons(ip->ip_len) - hlen))
+		fprintf(stderr, "Icmp checksum is wrong\n");
+
+	type = icp->icmp_type;
+	code = icp->icmp_code;
+	/* Path MTU Discovery (RFC1191) */
+	if (code != ICMP_UNREACH_NEEDFRAG)
+		pmtu = 0;
+	else {
+#ifdef HAVE_ICMP_NEXTMTU
+		pmtu = ntohs(icp->icmp_nextmtu);
+#else
+		pmtu = ntohs(((struct my_pmtu *)&icp->icmp_void)->ipm_nextmtu);
+#endif
+	}
+	if ((type == ICMP_TIMXCEED && code == ICMP_TIMXCEED_INTRANS) ||
+	    type == ICMP_UNREACH || type == ICMP_ECHOREPLY) {
+		register struct ip *hip;
+		register struct udphdr *up;
+		register struct icmp *hicmp;
+
+		hip = &icp->icmp_ip;
+		hlen = hip->ip_hl << 2;
+		if (useicmp) {
+			/* XXX */
+			if (type == ICMP_ECHOREPLY &&
+			    icp->icmp_id == htons(ident) &&
+			    icp->icmp_seq == htons(seq))
+				return (-2);
+
+			hicmp = (struct icmp *)((u_char *)hip + hlen);
+			/* XXX 8 is a magic number */
+			if (hlen + 8 <= cc &&
+			    hip->ip_p == IPPROTO_ICMP &&
+			    hicmp->icmp_id == htons(ident) &&
+			    hicmp->icmp_seq == htons(seq))
+				return (type == ICMP_TIMXCEED ? -1 : code + 1);
+		} else {
+			up = (struct udphdr *)((u_char *)hip + hlen);
+			/* XXX 8 is a magic number */
+			if (hlen + 12 <= cc &&
+			    hip->ip_p == IPPROTO_UDP &&
+#ifdef LAUGHTER
+			    up->uh_sport == htons(ident) &&
+#else
+			    up->uh_sport == uh_sport &&
+#endif
+			    up->uh_dport == htons(port + seq))
+				return (type == ICMP_TIMXCEED ? -1 : code + 1);
+		}
+	}
+#ifndef ARCHAIC
+	if (verbose) {
+		register int i;
+		u_int32_t *lp = (u_int32_t *)&icp->icmp_ip;
+
+		Printf("\n%d bytes from %s to ", cc, inet_ntoa(from->sin_addr));
+		Printf("%s: icmp type %d (%s) code %d\n",
+		    inet_ntoa(ip->ip_dst), type, pr_type(type), icp->icmp_code);
+		for (i = 4; i < cc ; i += sizeof(*lp))
+			Printf("%2d: x%8.8x\n", i, *lp++);
+	}
+#endif
+	return(0);
+}
+
+
+void
+print(register u_char *buf, register int cc, register struct sockaddr_in *from)
+{
+	register struct ip *ip;
+	register int hlen;
+
+	ip = (struct ip *) buf;
+	hlen = ip->ip_hl << 2;
+	cc -= hlen;
+
+	if (nflag)
+		Printf(" %s", inet_ntoa(from->sin_addr));
+	else
+		Printf(" %s (%s)", inetname(from->sin_addr),
+		    inet_ntoa(from->sin_addr));
+
+	if (verbose)
+		Printf(" %d bytes to %s", cc, inet_ntoa (ip->ip_dst));
+}
+
+/*
+ * Checksum routine for Internet Protocol family headers (C Version)
+ *
+ * Certainly, it was broken --ANK
+ */
+u_short
+in_cksum(register u_short *addr, register int len)
+{
+	register int nleft = len;
+	register u_short *w = addr;
+	register u_short answer;
+	register int sum = 0;
+
+	/*
+	 *  Our algorithm is simple, using a 32 bit accumulator (sum),
+	 *  we add sequential 16 bit words to it, and at the end, fold
+	 *  back all the carry bits from the top 16 bits into the lower
+	 *  16 bits.
+	 */
+	while (nleft > 1)  {
+		sum += *w++;
+		nleft -= 2;
+	}
+
+	/* mop up an odd byte, if necessary */
+	if (nleft == 1)
+		sum += htons(*(u_char *)w<<8);
+
+	/*
+	 * add back carry outs from top 16 bits to low 16 bits
+	 */
+	sum = (sum >> 16) + (sum & 0xffff);	/* add hi 16 to low 16 */
+	sum += (sum >> 16);			/* add carry */
+	answer = ~sum;				/* truncate to 16 bits */
+	return (answer);
+}
+
+/*
+ * Subtract 2 timeval structs:  out = out - in.
+ * Out is assumed to be >= in.
+ */
+void
+tvsub(register struct timeval *out, register struct timeval *in)
+{
+
+	if ((out->tv_usec -= in->tv_usec) < 0)   {
+		--out->tv_sec;
+		out->tv_usec += 1000000;
+	}
+	out->tv_sec -= in->tv_sec;
+}
+
+/*
+ * Construct an Internet address representation.
+ * If the nflag has been supplied, give
+ * numeric value, otherwise try for symbolic name.
+ */
+char *
+inetname(struct in_addr in)
+{
+	register char *cp;
+	register struct hostent *hp;
+	static int first = 1;
+	static char domain[MAXHOSTNAMELEN + 1], line[MAXHOSTNAMELEN + 1];
+
+	if (first && !nflag) {
+		first = 0;
+		if (gethostname(domain, sizeof(domain) - 1) < 0)
+			domain[0] = '\0';
+		else {
+			cp = strchr(domain, '.');
+			if (cp == NULL) {
+				hp = gethostbyname(domain);
+				if (hp != NULL)
+					cp = strchr(hp->h_name, '.');
+			}
+			if (cp == NULL)
+				domain[0] = '\0';
+			else {
+				++cp;
+				(void)strncpy(domain, cp, sizeof(domain) - 1);
+				domain[sizeof(domain) - 1] = '\0';
+			}
+		}
+	}
+	if (!nflag && in.s_addr != INADDR_ANY) {
+		hp = gethostbyaddr((char *)&in, sizeof(in), AF_INET);
+		if (hp != NULL) {
+			if ((cp = strchr(hp->h_name, '.')) != NULL &&
+			    strcmp(cp + 1, domain) == 0)
+				*cp = '\0';
+			(void)strncpy(line, hp->h_name, sizeof(line) - 1);
+			line[sizeof(line) - 1] = '\0';
+			return (line);
+		}
+	}
+	return (inet_ntoa(in));
+}
+
+struct hostinfo *
+gethostinfo(register char *hostname)
+{
+	register int n;
+	register struct hostent *hp;
+	register struct hostinfo *hi;
+	register char **p;
+	register u_int32_t addr, *ap;
+
+	if (strlen(hostname) > 64) {
+		Fprintf(stderr, "%s: hostname \"%.32s...\" is too long\n",
+		    prog, hostname);
+		exit(1);
+	}
+	hi = calloc(1, sizeof(*hi));
+	if (hi == NULL) {
+		Fprintf(stderr, "%s: calloc %s\n", prog, strerror(errno));
+		exit(1);
+	}
+	addr = inet_addr(hostname);
+	if ((int32_t)addr != -1) {
+		hi->name = strdup(hostname);
+		hi->n = 1;
+		hi->addrs = calloc(1, sizeof(hi->addrs[0]));
+		if (hi->addrs == NULL) {
+			Fprintf(stderr, "%s: calloc %s\n",
+			    prog, strerror(errno));
+			exit(1);
+		}
+		hi->addrs[0] = addr;
+		return (hi);
+	}
+
+	hp = gethostbyname(hostname);
+	if (hp == NULL) {
+		Fprintf(stderr, "%s: unknown host %s\n", prog, hostname);
+		exit(1);
+	}
+	if (hp->h_addrtype != AF_INET || hp->h_length != 4) {
+		Fprintf(stderr, "%s: bad host %s\n", prog, hostname);
+		exit(1);
+	}
+	hi->name = strdup(hp->h_name);
+	for (n = 0, p = hp->h_addr_list; *p != NULL; ++n, ++p)
+		continue;
+	hi->n = n;
+	hi->addrs = calloc(n, sizeof(hi->addrs[0]));
+	if (hi->addrs == NULL) {
+		Fprintf(stderr, "%s: calloc %s\n", prog, strerror(errno));
+		exit(1);
+	}
+	for (ap = hi->addrs, p = hp->h_addr_list; *p != NULL; ++ap, ++p)
+		memcpy(ap, *p, sizeof(*ap));
+	return (hi);
+}
+
+void
+freehostinfo(register struct hostinfo *hi)
+{
+	if (hi->name != NULL) {
+		free(hi->name);
+		hi->name = NULL;
+	}
+	free((char *)hi->addrs);
+	free((char *)hi);
+}
+
+void
+getaddr(register u_int32_t *ap, register char *hostname)
+{
+	register struct hostinfo *hi;
+
+	hi = gethostinfo(hostname);
+	*ap = hi->addrs[0];
+	freehostinfo(hi);
+}
+
+void
+setsin(register struct sockaddr_in *sin, register u_int32_t addr)
+{
+
+	memset(sin, 0, sizeof(*sin));
+#ifdef HAVE_SOCKADDR_SA_LEN
+	sin->sin_len = sizeof(*sin);
+#endif
+	sin->sin_family = AF_INET;
+	sin->sin_addr.s_addr = addr;
+}
+
+/* String to value with optional min and max. Handles decimal and hex. */
+int
+str2val(register const char *str, register const char *what,
+    register int mi, register int ma)
+{
+	register const char *cp;
+	register int val;
+	char *ep;
+
+	if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X')) {
+		cp = str + 2;
+		val = (int)strtol(cp, &ep, 16);
+	} else
+		val = (int)strtol(str, &ep, 10);
+	if (*ep != '\0') {
+		Fprintf(stderr, "%s: \"%s\" bad value for %s \n",
+		    prog, str, what);
+		exit(1);
+	}
+	if (val < mi && mi >= 0) {
+		if (mi == 0)
+			Fprintf(stderr, "%s: %s must be >= %d\n",
+			    prog, what, mi);
+		else
+			Fprintf(stderr, "%s: %s must be > %d\n",
+			    prog, what, mi - 1);
+		exit(1);
+	}
+	if (val > ma && ma >= 0) {
+		Fprintf(stderr, "%s: %s must be <= %d\n", prog, what, ma);
+		exit(1);
+	}
+	return (val);
+}
+
+__dead void
+usage(void)
+{
+	extern char version[];
+
+	Fprintf(stderr, "Version %s\n", version);
+	Fprintf(stderr,
+	    "Usage: %s [-dFInrvx] [-g gateway] [-i iface] [-f first_ttl]\n"
+	    "\t[-m max_ttl] [ -p port] [-q nqueries] [-s src_addr] [-t tos]\n"
+	    "\t[-w waittime] [-z pausemsecs] host [packetlen]\n", prog);
+	exit(1);
+}
+
+
+#ifdef USE_KERNEL_ROUTING_TABLE
+
+/* This function currently only supports IPv4.  Someone who knows
+ * more about multi-protocol socket stuff should take a look at this.
+ * 
+ * (But does it make any sense for traceroute to support other 
+ * protocols?  Maybe IPv6...
+ */
+
+struct ifaddrlist *search_routing_table(struct sockaddr_in *to, struct ifaddrlist *al, int n)
+{
+	struct ifaddrlist *first_if;
+	FILE *fp;
+	char buf[1024];
+	char ifname[128];
+        unsigned int route_dest;
+	unsigned int mask;
+	unsigned int best_mask;
+	unsigned int dest_addr;
+	unsigned int best_addr;
+	unsigned int gateway;
+	unsigned int use_gateway;
+	unsigned int convs;
+
+	/* How come using ntohl(to->sin_addr.s_addr) doesn't work here? */
+	dest_addr = to->sin_addr.s_addr;
+
+	fp = fopen("/proc/net/route", "r");
+	if (fp == NULL) {
+		return al;
+	}
+
+	/* Skip the first line (the column headings) */
+	if (fgets(buf, sizeof(buf), fp) == NULL) {
+		fclose(fp);
+		return al;
+	}
+
+	best_mask = 0;
+	best_addr = 0;
+	use_gateway = 0;
+	
+	while (fgets(buf, sizeof(buf), fp) != NULL) {
+		/* Field 1: interface name
+		 * Field 2: dest addr
+		 * Field 3: gateway addr
+		 * Field 8: genmask 
+		 */
+ 		convs = sscanf(buf, "%s %x %x %*s %*s %*s %*s %x", 
+ 				ifname, &route_dest, &gateway, &mask);
+ 		if (convs != 4) {
+			/* format error .... */
+			fclose(fp);
+			return al;
+		}
+
+		if ((dest_addr & mask) == route_dest) {
+			/* This routing entry applies to
+			 * our destination addr
+			 */
+			if ((mask > best_mask) || (best_mask == 0)) {
+				/* And it is more specific than any
+				 * previous match (or is the first match)
+				 */
+				best_mask = mask;
+				best_addr = route_dest;
+				use_gateway = gateway;
+			}
+		}
+	}
+
+	fclose(fp);
+
+	/* If we don't find a match, we'll return the first entry */
+	first_if = al;
+
+	while (al < first_if + n) {
+		/* Use different approach if we send through gateway */
+		if (use_gateway) {
+			if ((al->addr & al->mask) == (use_gateway & al->mask)) {
+				return al;
+			}
+		} else {
+		/* Better way than comparing if names,
+		   this works with aliased if:s too */
+		if (best_addr == (al->addr & al->mask)) {
+			/* Got a match */
+			return al;
+		}
+		}
+		al++;
+	}
+
+	return first_if;
+}
+			
+#endif
+
